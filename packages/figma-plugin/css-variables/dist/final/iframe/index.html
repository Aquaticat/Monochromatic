<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta
    name='viewport'
    content='width=device-width, initial-scale=1.0'>
  <title>iframe authored css</title>
  <script type="module" crossorigin>(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
// @__NO_SIDE_EFFECTS__
function isString(value) {
  return typeof value === "string";
}
function isDigitString(value) {
  return ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"].includes(value);
}
function isNo0DigitString(value) {
  return ["1", "2", "3", "4", "5", "6", "7", "8", "9"].includes(value);
}
function isDigitsString(value) {
  return /* @__PURE__ */ isString(value) && value.length > 0 && [...value].every(isDigitString);
}
function isPositiveIntString(value) {
  if (isDigitString(value)) {
    return true;
  }
  if (!/* @__PURE__ */ isString(value)) {
    return false;
  }
  if (isDigitString(value)) {
    return true;
  }
  if (value.length <= 1) {
    return false;
  }
  if (!isNo0DigitString(value[0])) {
    return false;
  }
  return isDigitsString(value.slice(1));
}
function isPositiveFloatString(value) {
  if (!/* @__PURE__ */ isString(value)) {
    return false;
  }
  if (value.length <= 2) {
    return false;
  }
  const dotIndex = value.indexOf(".");
  if (dotIndex === -1) {
    return false;
  }
  const intPart = value.slice(0, dotIndex);
  if (!isPositiveIntString(intPart)) {
    return false;
  }
  const floatPart = value.slice(dotIndex + 1);
  if ([...floatPart].every(function is0(floatPartDigit) {
    return floatPartDigit === "0";
  })) {
    return false;
  }
  return isDigitsString(floatPart);
}
function isPositiveNumberString(value) {
  return isPositiveIntString(value) || isPositiveFloatString(value);
}
const a = (t) => ({ [Symbol.iterator]: t }), r = (t) => Boolean(t && "function" == typeof t.then), c = (t) => {
  if (t.length <= 1 || f.has(t)) return t;
  const n = s(t, (...n2) => n2.length < t.length ? c(t.bind(null, ...n2)) : t(...n2));
  return f.add(n), n;
}, s = (t, n) => Object.defineProperties(n, { length: { value: t.length }, name: { value: t.name } }), f = /* @__PURE__ */ new WeakSet(), l = /* @__PURE__ */ c((t, n) => a(function* () {
  for (const a2 of n) yield t(a2);
})), P = (t) => "function" == typeof t ? t : t[Symbol.iterator] ? async (n) => {
  await Promise.all(l(n, t));
} : async (n) => {
  const a2 = [];
  for await (const e of t) {
    const t2 = n(e);
    r(t2) && a2.push(t2);
  }
  await Promise.all(a2);
}, Mn = /* @__PURE__ */ c((t, n) => n(t));
const DEFAULT_ELEMENT_WIDTH_NUMBER = 3840 - 8 * 2;
const testCssVar = async (cssValue, cssVar, mode, depth = 0) => {
  if (depth > 10) {
    throw new Error("Infinite loop detected");
  }
  console.log(
    `testCssVar(cssValue: ${cssValue}, cssVar: ${cssVar}, mode: ${mode}, depth: ${depth})`
  );
  const modeApplier = document.querySelector(`body > [data-mode="${mode}"]`) ?? function createModeApplier() {
    const createdModeApplier = document.createElement("div");
    createdModeApplier.dataset.mode = mode;
    document.body.append(createdModeApplier);
    return createdModeApplier;
  }();
  {
    const testElementAssumeUnitfulLength = document.createElement("div");
    testElementAssumeUnitfulLength.style.width = cssValue;
    testElementAssumeUnitfulLength.style.height = cssValue;
    modeApplier.append(testElementAssumeUnitfulLength);
    const computedStyle = window.getComputedStyle(
      testElementAssumeUnitfulLength
    );
    const computedWidth = computedStyle.getPropertyValue(
      "width"
    );
    testElementAssumeUnitfulLength.remove();
    if (computedWidth === `${DEFAULT_ELEMENT_WIDTH_NUMBER}px`) ;
    else {
      return {
        cssVar,
        originalValue: cssValue,
        computedValue: Number(computedWidth.slice(0, -"px".length)),
        varType: "number",
        mode,
        error: {
          message: `Figma doesn't support unitful length values,
                          consider using a number or string for this value.
                          If you're relying on the behavior of converting from rem to px,
                          you can safely ignore this error.`,
          level: cssValue.includes("em") ? "notice" : "error"
        },
        originalComputedValue: computedWidth
      };
    }
  }
  {
    const testElementAssumeNumber = document.createElement(
      "div"
    );
    testElementAssumeNumber.style.width = `${cssValue}px`;
    testElementAssumeNumber.style.height = `${cssValue}px`;
    modeApplier.append(testElementAssumeNumber);
    const computedStyle = window.getComputedStyle(
      testElementAssumeNumber
    );
    const computedWidth = computedStyle.getPropertyValue(
      "width"
    );
    testElementAssumeNumber.remove();
    if (computedWidth === `${DEFAULT_ELEMENT_WIDTH_NUMBER}px`) ;
    else {
      return {
        cssVar,
        originalValue: cssValue,
        computedValue: Number(computedWidth.slice(0, -"px".length)),
        varType: "number",
        mode,
        originalComputedValue: computedWidth
      };
    }
  }
  {
    const testElementAssumeColor = document.createElement(
      "div"
    );
    testElementAssumeColor.style.backgroundColor = cssValue;
    testElementAssumeColor.style.color = cssValue;
    document.body.append(testElementAssumeColor);
    const computedStyle = window.getComputedStyle(
      testElementAssumeColor
    );
    const computedBackgroundColor = computedStyle.getPropertyValue(
      "background-color"
    );
    const computedColor = computedStyle.getPropertyValue(
      "color"
    );
    testElementAssumeColor.remove();
    if (computedBackgroundColor === computedColor) {
      return {
        cssVar,
        originalValue: cssValue,
        computedValue: computedBackgroundColor,
        varType: "color",
        mode,
        originalComputedValue: computedBackgroundColor
      };
    }
  }
  {
    const testElementAssumeBoxShadow = document.createElement(
      "div"
    );
    testElementAssumeBoxShadow.style.boxShadow = cssValue;
    document.body.append(testElementAssumeBoxShadow);
    const computedStyle = window.getComputedStyle(
      testElementAssumeBoxShadow
    );
    const computedBoxShadow = computedStyle.getPropertyValue(
      "box-shadow"
    );
    testElementAssumeBoxShadow.remove();
    if (
      // If the element's background color and color are different,
      // it means at least one of them isn't applied.
      // It means the CSS var isn't a color value.
      computedBoxShadow === "none"
    ) ;
    else {
      return {
        cssVar,
        originalValue: cssValue,
        computedValue: computedBoxShadow,
        varType: "box-shadow",
        mode,
        originalComputedValue: computedBoxShadow
      };
    }
  }
  {
    const testElementAssumeString = document.createElement(
      "div"
    );
    testElementAssumeString.id = `testElementAssumeString${cssVar}`;
    testElementAssumeString.style.setProperty(cssVar, cssValue);
    const assumeStringStyleSheet = await new CSSStyleSheet().replace(
      `#testElementAssumeString${cssVar}::before { content: ${cssValue}; }`
    );
    document.adoptedStyleSheets.push(assumeStringStyleSheet);
    document.body.append(testElementAssumeString);
    const computedStyle = window.getComputedStyle(
      testElementAssumeString
    );
    const computedContent = computedStyle.getPropertyValue(
      "content"
    );
    if (computedContent === "none") {
      console.log`${cssVar} isn't a string (CSS content) value.
              Try treating it as something else.`;
    } else {
      return {
        cssVar,
        originalValue: cssValue,
        computedValue: cssValue.includes("var(--") ? cssValue.replaceAll("var(--", "var(--") : cssValue,
        varType: "string",
        mode,
        originalComputedValue: computedContent
      };
    }
  }
  return {
    cssVar,
    originalValue: cssValue,
    computedValue: cssValue,
    varType: "invalid",
    mode,
    error: {
      message: `${cssVar}'s ${cssValue} cannot be treated as a unitful length,
             a number, a color, a box-shadow, or a string (CSS content) value.`,
      level: "error"
    },
    originalComputedValue: cssValue
  };
};
const processCssVarRuleStyle = async (ruleStyle, rule, mode) => {
  const cssVar = ruleStyle;
  const cssValue = rule.style.getPropertyValue(cssVar);
  if (isPositiveNumberString(cssValue)) {
    window.parent.postMessage({
      authoredCss: {
        cssVar,
        originalValue: cssValue,
        computedValue: Number(cssValue),
        varType: "number",
        mode,
        originalComputedValue: cssValue
      }
    }, "*");
  } else if (cssValue === "true") {
    window.parent.postMessage({
      authoredCss: {
        cssVar,
        originalValue: cssValue,
        computedValue: true,
        varType: "boolean",
        mode,
        originalComputedValue: cssValue
      }
    }, "*");
  } else if (cssValue === "false") {
    window.parent.postMessage({
      authoredCss: {
        cssVar,
        originalValue: cssValue,
        computedValue: false,
        varType: "boolean",
        mode,
        originalComputedValue: cssValue
      }
    }, "*");
  } else {
    const authoredCss = await testCssVar(cssValue, cssVar, mode, 0);
    window.parent.postMessage({ authoredCss }, "*");
  }
};
const processBasicRule = async (rule, mode) => {
  const ruleStyles = [];
  for (let i = 0; i < rule.style.length; i++) {
    ruleStyles.push(rule.style.item(i));
  }
  await Mn(
    async function processRuleStyle(ruleStyle) {
      if (ruleStyle.startsWith("--")) {
        await processCssVarRuleStyle(ruleStyle, rule, mode);
      }
    },
    P(ruleStyles)
  );
};
const processNonBasicRule = (rule) => {
  console.log(`non-basic rule: ${rule.selectorText}`);
};
const processRule = async (rule) => {
  if (/^\[data-mode=(?:"\w+"|'\w+')]$/.test(rule.selectorText.trim())) {
    const mode = rule.selectorText.trim().slice('[data-mode="'.length, -'"]'.length);
    await processBasicRule(rule, mode);
  } else {
    processNonBasicRule(rule);
  }
};
const handleReceivingCss = async (event) => {
  const sheet = await new CSSStyleSheet().replace(event.data.css);
  document.adoptedStyleSheets = [sheet];
  window.parent.postMessage(
    { authoredCss: "adopted stylesheets applied" },
    "*"
  );
  const ruleList = sheet.cssRules;
  const rules = [];
  for (let i = 0; i < ruleList.length; i++) {
    rules.push(ruleList.item(i));
  }
  await Mn(
    processRule,
    P(rules)
  );
};
const messageHandler = async (event) => {
  if (Object.hasOwn(event.data, "css")) {
    await handleReceivingCss(event);
  }
};
window.addEventListener("message", messageHandler);</script>
</head>
<body>
</body>
</html>
