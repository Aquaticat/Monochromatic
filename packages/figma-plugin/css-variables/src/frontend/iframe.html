<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='UTF-8'>
    <meta
      name='viewport'
      content='width=device-width, initial-scale=1.0'>
    <title>iframe authored css</title>
  </head>
  <body>
    <script>
    const DEFAULT_ELEMENT_WIDTH_NUMBER = 3840 - 8 * 2;

      async function testCssVar(
        /** @type {string} */ cssValue,
        /** @type {string} */ cssVar,
      ) {
        await Promise.all([
          (async function unitFulLength() {
            const testElementAssumeUnitfulLength = document.createElement('div');
            testElementAssumeUnitfulLength.style.width = cssValue;
            testElementAssumeUnitfulLength.style.height = cssValue;
            document.body.appendChild(testElementAssumeUnitfulLength);

            const computedStyle = window.getComputedStyle(
              testElementAssumeUnitfulLength,
            );
            const computedWidth = computedStyle.getPropertyValue(
              'width',
            );
            try {
              if (
                computedWidth
                  === `${DEFAULT_ELEMENT_WIDTH_NUMBER}px`
              ) {
                console.log(
                  `${cssVar} isn't a unitful length value. Try treating it as a number`,
                );
              } else {
                window.postMessage({
                  authoredCss: {
                    cssVar,
                    originalValue: cssValue,
                    computedValue: computedWidth.slice(0, -('px'.length)),
                    cssVarType: 'number',
                    error: {
                      message: `Figma doesn't support unitful length values,
                          consider using a number or string for this value.
                          If you're relying on the behavior of converting from rem to px,
                          you can safely ignore this error.`,
                      level: cssValue.includes('em') ? 'notice' : 'error',
                    },
                  },
                });
              }
            } finally {
              testElementAssumeUnitfulLength.remove();
            }
          })(),
          (async function number() {
            const testElementAssumeNumber = document.createElement(
              'div',
            );
            testElementAssumeNumber.style.width = `${cssValue}px`;
            testElementAssumeNumber.style.height = `${cssValue}px`;
            document.body.appendChild(testElementAssumeNumber);

            const computedStyle = window.getComputedStyle(
              testElementAssumeNumber,
            );
            const computedWidth = computedStyle.getPropertyValue(
              'width',
            );
            if (
              computedWidth
                === `${DEFAULT_ELEMENT_WIDTH_NUMBER}px`
            ) {
              console.log(
                `${cssVar} isn't a number value. Try treating it as a unitful length value`,
              );
            } else {
              window.postMessage({
                authoredCss: {
                  cssVar,
                  originalValue: cssValue,
                  computedValue: computedWidth.slice(0, -('px'.length)),
                  varType: 'number',
                },
              });
            }
            testElementAssumeNumber.remove();
          })(),
          (async function color() {
            const testElementAssumeColor = document.createElement(
              'div',
            );
            testElementAssumeColor.style.backgroundColor = cssValue;
            testElementAssumeColor.style.color = cssValue;
            document.body.appendChild(testElementAssumeColor);

            const computedStyle = window.getComputedStyle(
              testElementAssumeColor,
            );
            const computedBackgroundColor = computedStyle
              .getPropertyValue(
                'background-color',
              );
            const computedColor = computedStyle.getPropertyValue(
              'color',
            );
            if (
              // If the element's background color and color are different,
              // it means at least one of them isn't applied.
              // It means the CSS var isn't a color value.
              computedBackgroundColor
                !== computedColor
            ) {
              console.log(
                `${cssVar} isn't a color value. Try treating it as something else.`,
              );
            } else {
              window.postMessage({
                authoredCss: {
                  cssVar,
                  originalValue: cssValue,
                  computedValue: computedBackgroundColor,
                  varType: 'color',
                },
              });
            }
            testElementAssumeColor.remove();
          })(),
          (async function boxShadow() {
            const testElementAssumeBoxShadow = document.createElement(
              'div',
            );
            testElementAssumeBoxShadow.style.boxShadow = cssValue;
            document.body.appendChild(testElementAssumeBoxShadow);

            const computedStyle = window.getComputedStyle(
              testElementAssumeBoxShadow,
            );
            const computedBoxShadow = computedStyle
              .getPropertyValue(
                'box-shadow',
              );

            if (
              // If the element's background color and color are different,
              // it means at least one of them isn't applied.
              // It means the CSS var isn't a color value.
              computedBoxShadow === 'none'
            ) {
              console.log(
                `${cssVar} isn't a box-shadow value. Try treating it as something else.`,
              );
            } else {
              window.postMessage({
                authoredCss: {
                  cssVar,
                  originalValue: cssValue,
                  computedValue: computedBoxShadow,
                  varType: 'box-shadow',
                },
              });
            }
            testElementAssumeBoxShadow.remove();
          })(),
          // If all else fails, assume it's a string.
          // Or should I have filtered out the strings before getting them inside the iframe?
        ]);
      }

      const processCssVarRuleStyle = async (
        /** @type { string } */ ruleStyle,
        /** @type { CSSStyleRule & {selectorText: string}} */ rule,
      ) => {
        const cssVar = ruleStyle;
        const cssValue = rule.style.getPropertyValue(cssVar);
        console.log(`css var: ${cssVar} value: ${cssValue}`);

        // low-hanging fruit:
        // If the CSS var is a number at first glance,
        // skip everything and send the value to the backend.
        // noinspection JSCheckFunctionSignatures
        if (
          !isNaN(cssValue)
          && !isNaN(parseFloat(cssValue))
        ) {
          window.postMessage({
            authoredCss: {
              cssVar,
              originalValue: cssValue,
              computedValue: Number(cssValue),
              varType: 'number',
            },
          });
        } else {
          // create multiple test elements to test the CSS var
          await testCssVar(cssValue, cssVar);
        }
      };

      const processBasicRule = async (
        /** @type { CSSStyleRule & {selectorText: string}} */ rule,
      ) => {
        // console.log(rule.style);

        for (const /** @type {string} */ ruleStyle of rule.style) {
          if (ruleStyle.startsWith('--')) {
            await processCssVarRuleStyle(ruleStyle, rule);
          } else {
            // console.log(`non-css var: ${ruleStyle}`);
          }
        }
      };

      const processNonBasicRule = (
        /** @type { CSSStyleRule & {selectorText: string}} */ rule,
      ) => {
        console.log(`non-basic rule: ${rule.selectorText}`);
      };

      const processRule = async (
        /** @type { CSSStyleRule & {selectorText: string}} */ rule,
      ) => /** @type {VoidFunction} */ {
        // Basic Rules
        if (rule.selectorText === ':root') {
          await processBasicRule(rule);
        } else {
          processNonBasicRule(rule);
        }
      };

      const handleReceivingCss = async (/** @type {MessageEvent<any>} */ event) => {
        console.log(`inner iframe received message: ${event.data.css}`);
        const sheet = await new CSSStyleSheet().replace(event.data.css);
        document.adoptedStyleSheets = [sheet];
        event.source.postMessage({ authoredCss: 'adopted stylesheets applied' },
          '*');

        const ruleList = sheet.cssRules;
        // Have to use jsdoc/tsdoc in this document because this is parsed as JS
        for (
          const /** @type {CSSStyleRule & {selectorText: string}} */ rule
            of ruleList
        ) {
          await processRule(rule);
        }
      };

      const messageHandler = async (/** @type {MessageEvent<any>} */ event) => {
        if (Object.hasOwn(event.data, 'css')) await handleReceivingCss(event);
      };
      window.addEventListener('message', messageHandler);
    </script>
  </body>
</html>
