var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,"name",{value,configurable:!0});import{fs,path}from"@monochromatic-dev/module-fs-path";var __defProp2=Object.defineProperty,__name2=__name((target,value)=>__defProp2(target,"name",{value,configurable:!0}),"__name"),__defProp22=Object.defineProperty,__name22=__name2((target,value)=>__defProp22(target,"name",{value,configurable:!0}),"__name"),src_default=__name22(obj=>{switch(!0){case obj===null:return"null";case obj===void 0:return"undefined";case Number.isNaN(obj):return"NaN";case typeof obj=="number":return"number";case typeof obj=="boolean":return"boolean";case typeof obj=="bigint":return"bigint";case typeof obj=="symbol":return"symbol";case typeof obj=="string":return"string";case Array.isArray(obj):return"array";case obj instanceof Date:return"date";case obj instanceof Set:return"set";case obj instanceof Map:return"map";case String(obj).startsWith("[object Object]"):return"object";default:throw TypeError(`Unrecognized obj ${obj} ${JSON.stringify(obj)} ${typeof obj}`)}},"default"),unsupported=Object.freeze(["null","undefined","NaN","bigint","symbol"]),primitive=Object.freeze(["boolean","string","number","date"]);function toExport(obj){let objType=src_default(obj);if(unsupported.includes(objType))throw new TypeError(`Unsupported obj ${obj} ${JSON.stringify(obj)} type ${objType}`);if(primitive.includes(objType))switch(objType){case"boolean":return String(obj);case"number":return String(obj);case"string":return`${JSON.stringify(obj)}`;case"date":return`new Date(${JSON.stringify(obj)})`}switch(objType){case"set":return`Object.freeze(new Set([${Array.from(obj).map(([k,v])=>`[${toExport(k)}, ${toExport(v)}]`)}]))`;case"map":return`Object.freeze(new Map([${Array.from(obj).map(([k,v])=>`[${toExport(k)}, ${toExport(v)}]`)}]))`;case"array":return`Object.freeze([${obj.map(i=>toExport(i))}])`;case"object":return`Object.freeze(Object.fromEntries([${Object.entries(obj).map(([k,v])=>`[${toExport(k)}, ${toExport(v)}]`)}]))`;default:throw new TypeError(`Unknown obj ${obj} ${JSON.stringify(obj)} type ${objType}`)}}__name(toExport,"toExport");__name2(toExport,"toExport");import pm from"@monochromatic-dev/module-pm";import resolve from"@monochromatic-dev/module-resolve";import{findUpMultiple}from"find-up";import memoizeFs from"memoize-fs";var{isArray}=Array;function curry(fn,args=[]){return(..._args)=>(rest=>rest.length>=fn.length?fn(...rest):curry(fn,rest))([...args,..._args])}__name(curry,"curry");var ReduceStopper=class{static{__name(this,"ReduceStopper")}constructor(value){this.value=value}};function reduceFn(reducer,acc,list){if(list==null)return acc;if(!isArray(list))throw new TypeError("reduce: list must be array or iterable");let index=0,len=list.length;for(;index<len;){if(acc=reducer(acc,list[index],index,list),acc instanceof ReduceStopper)return acc.value;index++}return acc}__name(reduceFn,"reduceFn");var reduce=curry(reduceFn);function pipeAsync(...fnList){return function(startArgument){return reduce(async(value,fn)=>fn(await value),startArgument,fnList)}}__name(pipeAsync,"pipeAsync");async function mapParallelAsyncFn(fn,arr){let promised=arr.map((a,i)=>fn(a,i));return Promise.all(promised)}__name(mapParallelAsyncFn,"mapParallelAsyncFn");function mapParallelAsync(fn,arr){return arguments.length===1?async holder=>mapParallelAsyncFn(fn,holder):new Promise((resolve2,reject)=>{mapParallelAsyncFn(fn,arr).then(resolve2).catch(reject)})}__name(mapParallelAsync,"mapParallelAsync");function pipedAsync(input,...fnList){return pipeAsync(...fnList)(input)}__name(pipedAsync,"pipedAsync");import{parse}from"smol-toml";var isSchemaAsync=__name(schema=>Object.hasOwn(schema,"parseAsync"),"isSchemaAsync"),memoizer=memoizeFs({cachePath:"dist/temp/cache/",cacheId:"toml",astBody:!0,retryOnInvalidCache:!0}),tomlToJsWoCache=__name(async(input,inputPath,options)=>{let mergeParent=options?.mergeParent??!1,mergeParents=mergeParent===!0?["index.toml"]:mergeParent===!1?[]:typeof mergeParent=="string"?[mergeParent]:mergeParent,schema=options?.schema??!1,injectMetadata=options?.injectMetadata??!1,save=options?.save??!1,saveTo=save===!0?["dist/temp/toml"]:save===!1?[]:typeof save=="string"?[save]:save,ownJson=parse(input),pkgJsonAbsPath=(await pm(inputPath)).packageAbsDir,mergedJson=mergeParent?{...await pipedAsync(await findUpMultiple(mergeParents,{cwd:(await path.parseFs(inputPath)).dir,stopAt:pkgJsonAbsPath}),async indexTomlAbsPaths=>await mapParallelAsync(async indexTomlAbsPath=>pipedAsync(indexTomlAbsPath,fs.readFileU,parse),indexTomlAbsPaths),indexTomlContents=>indexTomlContents.toReversed(),reversedIndexTomlContents=>Object.assign({},...reversedIndexTomlContents)),...ownJson}:ownJson,injectedJson=injectMetadata?{...mergedJson,path:await path.parseFs(inputPath),pkgJsonAbsPath}:mergedJson,schemaed=schema?isSchemaAsync(schema)?await schema.parseAsync(injectedJson):schema.parse(injectedJson):injectedJson,res=`export default ${toExport(schemaed)}`;return await mapParallelAsync(async outputDirPath=>await fs.outputFile(path.join(outputDirPath,path.relative(path.join(path.resolve(),"src"),inputPath)),res),saveTo),res},"tomlToJsWoCache"),tomlToJs=await memoizer.fn(tomlToJsWoCache),src_default2=__name(options=>{let mergeParent=options?.mergeParent??!1,mergeParents=mergeParent===!0?["index.toml"]:mergeParent===!1?[]:typeof mergeParent=="string"?[mergeParent]:mergeParent,schema=options?.schema??!1,injectMetadata=options?.injectMetadata??!1,save=options?.save??!1;return{name:"toml",setup(build){let saveTo=save===!0?[build.initialOptions.outdir??"dist/temp/toml"]:save===!1?[]:typeof save=="string"?[save]:save;build.onResolve({filter:/\.toml$/},async args=>({path:await resolve(args.path,args.importer),namespace:"toml"})),build.onLoad({filter:/.*/,namespace:"toml"},async args=>{let input=await fs.readFileMU(args.path);return{contents:await tomlToJs(input,args.path,{mergeParent:mergeParents,schema,injectMetadata,save:saveTo}),resolveDir:(await path.parseFs(args.path)).dir}})}}},"default");export{src_default2 as default,tomlToJs};
