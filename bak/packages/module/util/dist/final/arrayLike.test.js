var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,"name",{value,configurable:!0});var AssertionError=class extends Error{static{__name(this,"AssertionError")}constructor(message,options){super(message,options),this.name="AssertionError"}};var customEqualityTesters=[];function addCustomEqualityTesters(newTesters){if(!Array.isArray(newTesters))throw new TypeError(`customEqualityTester expects an array of Testers. But got ${typeof newTesters}`);customEqualityTesters.push(...newTesters)}__name(addCustomEqualityTesters,"addCustomEqualityTesters");function getCustomEqualityTesters(){return customEqualityTesters}__name(getCustomEqualityTesters,"getCustomEqualityTesters");var AsymmetricMatcher=class{static{__name(this,"AsymmetricMatcher")}value;constructor(value){this.value=value}},Anything=class extends AsymmetricMatcher{static{__name(this,"Anything")}equals(other){return other!=null}};function anything(){return new Anything}__name(anything,"anything");var Any=class extends AsymmetricMatcher{static{__name(this,"Any")}constructor(value){if(value===void 0)throw new TypeError("Expected a constructor function");super(value)}equals(other){return typeof other=="object"?other instanceof this.value:this.value===Number?typeof other=="number":this.value===String?typeof other=="string":this.value===Number?typeof other=="number":this.value===Function?typeof other=="function":this.value===Boolean?typeof other=="boolean":this.value===BigInt?typeof other=="bigint":this.value===Symbol?typeof other=="symbol":!1}};function any(c){return new Any(c)}__name(any,"any");var ArrayContaining=class extends AsymmetricMatcher{static{__name(this,"ArrayContaining")}constructor(arr){super(arr)}equals(other){return Array.isArray(other)&&this.value.every(e=>other.includes(e))}};function arrayContaining(c){return new ArrayContaining(c)}__name(arrayContaining,"arrayContaining");var CloseTo=class extends AsymmetricMatcher{static{__name(this,"CloseTo")}#precision;constructor(num,precision=2){super(num),this.#precision=precision}equals(other){return typeof other!="number"?!1:this.value===Number.POSITIVE_INFINITY&&other===Number.POSITIVE_INFINITY||this.value===Number.NEGATIVE_INFINITY&&other===Number.NEGATIVE_INFINITY?!0:Math.abs(this.value-other)<Math.pow(10,-this.#precision)/2}};function closeTo(num,numDigits){return new CloseTo(num,numDigits)}__name(closeTo,"closeTo");var StringContaining=class extends AsymmetricMatcher{static{__name(this,"StringContaining")}constructor(str){super(str)}equals(other){return typeof other!="string"?!1:other.includes(this.value)}};function stringContaining(str){return new StringContaining(str)}__name(stringContaining,"stringContaining");var StringMatching=class extends AsymmetricMatcher{static{__name(this,"StringMatching")}constructor(pattern){super(new RegExp(pattern))}equals(other){return typeof other!="string"?!1:this.value.test(other)}};function stringMatching(pattern){return new StringMatching(pattern)}__name(stringMatching,"stringMatching");function isKeyedCollection(x){return[Symbol.iterator,"size"].every(k=>k in x)}__name(isKeyedCollection,"isKeyedCollection");function constructorsEqual(a,b){return a.constructor===b.constructor||a.constructor===Object&&!b.constructor||!a.constructor&&b.constructor===Object}__name(constructorsEqual,"constructorsEqual");function asymmetricEqual(a,b){let asymmetricA=a instanceof AsymmetricMatcher,asymmetricB=b instanceof AsymmetricMatcher;if(!(asymmetricA&&asymmetricB)){if(asymmetricA)return a.equals(b);if(asymmetricB)return b.equals(a)}}__name(asymmetricEqual,"asymmetricEqual");function equal(c,d,options){let{customTesters=[],strictCheck}=options||{},seen=new Map;return __name(function compare(a,b){if(customTesters?.length)for(let customTester of customTesters){let testContext={equal},pass=customTester.call(testContext,a,b,customTesters);if(pass!==void 0)return pass}if(a&&b&&(a instanceof RegExp&&b instanceof RegExp||a instanceof URL&&b instanceof URL))return String(a)===String(b);let asymmetric=asymmetricEqual(a,b);if(asymmetric!==void 0)return asymmetric;if(a instanceof Date&&b instanceof Date){let aTime=a.getTime(),bTime=b.getTime();return Number.isNaN(aTime)&&Number.isNaN(bTime)?!0:aTime===bTime}if(a instanceof Error&&b instanceof Error)return a.message===b.message;if(typeof a=="number"&&typeof b=="number")return Number.isNaN(a)&&Number.isNaN(b)||a===b;if(a===null||b===null)return a===b;if(Object.prototype.toString.call(a)!==Object.prototype.toString.call(b))return!1;if(Object.is(a,b))return!0;if(a&&typeof a=="object"&&b&&typeof b=="object"){if(strictCheck&&a&&b&&!constructorsEqual(a,b))return!1;if(a instanceof WeakMap||b instanceof WeakMap){if(!(a instanceof WeakMap&&b instanceof WeakMap))return!1;throw new TypeError("cannot compare WeakMap instances")}if(a instanceof WeakSet||b instanceof WeakSet){if(!(a instanceof WeakSet&&b instanceof WeakSet))return!1;throw new TypeError("cannot compare WeakSet instances")}if(seen.get(a)===b)return!0;let aKeys=Object.keys(a||{}),bKeys=Object.keys(b||{}),aLen=aKeys.length,bLen=bKeys.length;if(!strictCheck){if(aLen>0)for(let i=0;i<aKeys.length;i+=1){let key=aKeys[i];key in a&&a[key]===void 0&&!(key in b)&&(aLen-=1)}if(bLen>0)for(let i=0;i<bKeys.length;i+=1){let key=bKeys[i];key in b&&b[key]===void 0&&!(key in a)&&(bLen-=1)}}if(aLen!==bLen)return!1;if(seen.set(a,b),isKeyedCollection(a)&&isKeyedCollection(b)){if(a.size!==b.size)return!1;let unmatchedEntries=a.size;for(let[aKey,aValue]of a.entries())for(let[bKey,bValue]of b.entries())if(aKey===aValue&&bKey===bValue&&compare(aKey,bKey)||compare(aKey,bKey)&&compare(aValue,bValue)){unmatchedEntries--;break}return unmatchedEntries===0}let merged={...a,...b};for(let key of[...Object.getOwnPropertyNames(merged),...Object.getOwnPropertySymbols(merged)])if(!compare(a&&a[key],b&&b[key])||key in a&&a[key]!==void 0&&!(key in b)||key in b&&b[key]!==void 0&&!(key in a))return!1;return a instanceof WeakRef||b instanceof WeakRef?a instanceof WeakRef&&b instanceof WeakRef?compare(a.deref(),b.deref()):!1:!0}return!1},"compare")(c,d)}__name(equal,"equal");var extendMatchers={};function getExtendMatchers(){return extendMatchers}__name(getExtendMatchers,"getExtendMatchers");function setExtendMatchers(newExtendMatchers){extendMatchers={...extendMatchers,...newExtendMatchers}}__name(setExtendMatchers,"setExtendMatchers");function format(v){let{Deno:Deno2}=globalThis;return typeof Deno2?.inspect=="function"?Deno2.inspect(v,{depth:1/0,sorted:!0,trailingComma:!0,compact:!1,iterableLimit:1/0,getters:!0,strAbbreviateSize:1/0}):`"${String(v).replace(/(?=["\\])/g,"\\")}"`}__name(format,"format");function assertNotStrictEquals(actual,expected,msg){if(!Object.is(actual,expected))return;let msgSuffix=msg?`: ${msg}`:".";throw new AssertionError(`Expected "actual" to not be strictly equal to: ${format(actual)}${msgSuffix}
`)}__name(assertNotStrictEquals,"assertNotStrictEquals");var{Deno}=globalThis,noColor=typeof Deno?.noColor=="boolean"?Deno.noColor:!1,enabled=!noColor;function code(open,close){return{open:`\x1B[${open.join(";")}m`,close:`\x1B[${close}m`,regexp:new RegExp(`\\x1b\\[${close}m`,"g")}}__name(code,"code");function run(str,code2){return enabled?`${code2.open}${str.replace(code2.regexp,code2.open)}${code2.close}`:str}__name(run,"run");function bold(str){return run(str,code([1],22))}__name(bold,"bold");function red(str){return run(str,code([31],39))}__name(red,"red");function green(str){return run(str,code([32],39))}__name(green,"green");function white(str){return run(str,code([37],39))}__name(white,"white");function gray(str){return brightBlack(str)}__name(gray,"gray");function brightBlack(str){return run(str,code([90],39))}__name(brightBlack,"brightBlack");function bgRed(str){return run(str,code([41],49))}__name(bgRed,"bgRed");function bgGreen(str){return run(str,code([42],49))}__name(bgGreen,"bgGreen");var ANSI_PATTERN=new RegExp(["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"].join("|"),"g");function stripAnsiCode(string){return string.replace(ANSI_PATTERN,"")}__name(stripAnsiCode,"stripAnsiCode");function createColor(diffType,background=!1){switch(diffType){case"added":return s=>background?bgGreen(white(s)):green(bold(s));case"removed":return s=>background?bgRed(white(s)):red(bold(s));default:return white}}__name(createColor,"createColor");function createSign(diffType){switch(diffType){case"added":return"+   ";case"removed":return"-   ";default:return"    "}}__name(createSign,"createSign");function buildMessage(diffResult,options={}){let{stringDiff=!1}=options,messages=["","",`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`,"",""],diffMessages=diffResult.map(result=>{let color=createColor(result.type),line=result.details?.map(detail=>detail.type!=="common"?createColor(detail.type,!0)(detail.value):detail.value).join("")??result.value;return color(`${createSign(result.type)}${line}`)});return messages.push(...stringDiff?[diffMessages.join("")]:diffMessages,""),messages}__name(buildMessage,"buildMessage");function createCommon(A,B){let common=[];if(A.length===0||B.length===0)return[];for(let i=0;i<Math.min(A.length,B.length);i+=1){let a=A[i],b=B[i];if(a!==void 0&&a===b)common.push(a);else return common}return common}__name(createCommon,"createCommon");function assertFp(value){if(value==null||typeof value!="object"||typeof value?.y!="number"||typeof value?.id!="number")throw new Error("Unexpected missing FarthestPoint")}__name(assertFp,"assertFp");function backTrace(A,B,current,swapped,routes,diffTypesPtrOffset){let M=A.length,N=B.length,result=[],a=M-1,b=N-1,j=routes[current.id],type=routes[current.id+diffTypesPtrOffset];for(;!(!j&&!type);){let prev=j;type===1?(result.unshift({type:swapped?"removed":"added",value:B[b]}),b-=1):type===3?(result.unshift({type:swapped?"added":"removed",value:A[a]}),a-=1):(result.unshift({type:"common",value:A[a]}),a-=1,b-=1),j=routes[prev],type=routes[prev+diffTypesPtrOffset]}return result}__name(backTrace,"backTrace");function createFp(k,M,routes,diffTypesPtrOffset,ptr,slide,down){if(slide&&slide.y===-1&&down&&down.y===-1)return{y:0,id:0};let isAdding=down?.y===-1||k===M||(slide?.y||0)>(down?.y||0)+1;if(slide&&isAdding){let prev=slide.id;return ptr++,routes[ptr]=prev,routes[ptr+diffTypesPtrOffset]=3,{y:slide.y,id:ptr}}if(down&&!isAdding){let prev=down.id;return ptr++,routes[ptr]=prev,routes[ptr+diffTypesPtrOffset]=1,{y:down.y+1,id:ptr}}throw new Error("Unexpected missing FarthestPoint")}__name(createFp,"createFp");function diff(A,B){let prefixCommon=createCommon(A,B);A=A.slice(prefixCommon.length),B=B.slice(prefixCommon.length);let swapped=B.length>A.length;[A,B]=swapped?[B,A]:[A,B];let M=A.length,N=B.length;if(!M&&!N&&!prefixCommon.length)return[];if(!N)return[...prefixCommon.map(value=>({type:"common",value})),...A.map(value=>({type:swapped?"added":"removed",value}))];let offset=N,delta=M-N,length=M+N+1,fp=Array.from({length},()=>({y:-1,id:-1})),routes=new Uint32Array((M*N+length+1)*2),diffTypesPtrOffset=routes.length/2,ptr=0;function snake(k,A2,B2,slide,down){let M2=A2.length,N2=B2.length,fp2=createFp(k,M2,routes,diffTypesPtrOffset,ptr,slide,down);for(ptr=fp2.id;fp2.y+k<M2&&fp2.y<N2&&A2[fp2.y+k]===B2[fp2.y];){let prev=fp2.id;ptr++,fp2.id=ptr,fp2.y+=1,routes[ptr]=prev,routes[ptr+diffTypesPtrOffset]=2}return fp2}__name(snake,"snake");let currentFp=fp[delta+offset];assertFp(currentFp);let p=-1;for(;currentFp.y<N;){p=p+1;for(let k=-p;k<delta;++k){let index2=k+offset;fp[index2]=snake(k,A,B,fp[index2-1],fp[index2+1])}for(let k=delta+p;k>delta;--k){let index2=k+offset;fp[index2]=snake(k,A,B,fp[index2-1],fp[index2+1])}let index=delta+offset;fp[delta+offset]=snake(delta,A,B,fp[index-1],fp[index+1]),currentFp=fp[delta+offset],assertFp(currentFp)}return[...prefixCommon.map(value=>({type:"common",value})),...backTrace(A,B,currentFp,swapped,routes,diffTypesPtrOffset)]}__name(diff,"diff");function unescape(string){return string.replaceAll("\b","\\b").replaceAll("\f","\\f").replaceAll("	","\\t").replaceAll("\v","\\v").replaceAll(/\r\n|\r|\n/g,str=>str==="\r"?"\\r":str===`
`?`\\n
`:`\\r\\n\r
`)}__name(unescape,"unescape");var WHITESPACE_SYMBOLS=/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/;function tokenize(string,wordDiff=!1){if(wordDiff)return string.split(WHITESPACE_SYMBOLS).filter(token=>token);let tokens=[],lines=string.split(/(\n|\r\n)/).filter(line=>line);for(let[i,line]of lines.entries())i%2?tokens[tokens.length-1]+=line:tokens.push(line);return tokens}__name(tokenize,"tokenize");function createDetails(line,tokens){return tokens.filter(({type})=>type===line.type||type==="common").map((result,i,t)=>{let token=t[i-1];return result.type==="common"&&token&&token.type===t[i+1]?.type&&/\s+/.test(result.value)?{...result,type:token.type}:result})}__name(createDetails,"createDetails");function diffStr(A,B){let diffResult=diff(tokenize(`${unescape(A)}
`),tokenize(`${unescape(B)}
`)),added=[],removed=[];for(let result of diffResult)result.type==="added"&&added.push(result),result.type==="removed"&&removed.push(result);let hasMoreRemovedLines=added.length<removed.length,aLines=hasMoreRemovedLines?added:removed,bLines=hasMoreRemovedLines?removed:added;for(let a of aLines){let tokens=[],b;for(;bLines.length;){b=bLines.shift();let tokenized=[tokenize(a.value,!0),tokenize(b.value,!0)];if(hasMoreRemovedLines&&tokenized.reverse(),tokens=diff(tokenized[0],tokenized[1]),tokens.some(({type,value})=>type==="common"&&value.trim().length))break}a.details=createDetails(a,tokens),b&&(b.details=createDetails(b,tokens))}return diffResult}__name(diffStr,"diffStr");function assertStrictEquals(actual,expected,msg){if(Object.is(actual,expected))return;let msgSuffix=msg?`: ${msg}`:".",message,actualString=format(actual),expectedString=format(expected);if(actualString===expectedString){let withOffset=actualString.split(`
`).map(l3=>`    ${l3}`).join(`
`);message=`Values have the same structure but are not reference-equal${msgSuffix}

${red(withOffset)}
`}else{let stringDiff=typeof actual=="string"&&typeof expected=="string",diffResult=stringDiff?diffStr(actual,expected):diff(actualString.split(`
`),expectedString.split(`
`)),diffMsg=buildMessage(diffResult,{stringDiff}).join(`
`);message=`Values are not strictly equal${msgSuffix}
${diffMsg}`}throw new AssertionError(message)}__name(assertStrictEquals,"assertStrictEquals");function assertInstanceOf(actual,expectedType,msg=""){if(actual instanceof expectedType)return;let msgSuffix=msg?`: ${msg}`:".",expectedTypeStr=expectedType.name,actualTypeStr="";throw actual===null?actualTypeStr="null":actual===void 0?actualTypeStr="undefined":typeof actual=="object"?actualTypeStr=actual.constructor?.name??"Object":actualTypeStr=typeof actual,expectedTypeStr===actualTypeStr?msg=`Expected object to be an instance of "${expectedTypeStr}"${msgSuffix}`:actualTypeStr==="function"?msg=`Expected object to be an instance of "${expectedTypeStr}" but was not an instanced object${msgSuffix}`:msg=`Expected object to be an instance of "${expectedTypeStr}" but was "${actualTypeStr}"${msgSuffix}`,new AssertionError(msg)}__name(assertInstanceOf,"assertInstanceOf");function assertIsError(error,ErrorClass,msgMatches,msg){let msgSuffix=msg?`: ${msg}`:".";if(!(error instanceof Error))throw new AssertionError(`Expected "error" to be an Error object${msgSuffix}}`);if(ErrorClass&&!(error instanceof ErrorClass))throw msg=`Expected error to be instance of "${ErrorClass.name}", but was "${error?.constructor?.name}"${msgSuffix}`,new AssertionError(msg);let msgCheck;if(typeof msgMatches=="string"&&(msgCheck=stripAnsiCode(error.message).includes(stripAnsiCode(msgMatches))),msgMatches instanceof RegExp&&(msgCheck=msgMatches.test(stripAnsiCode(error.message))),msgMatches&&!msgCheck)throw msg=`Expected error message to include ${msgMatches instanceof RegExp?msgMatches.toString():JSON.stringify(msgMatches)}, but got ${JSON.stringify(error?.message)}${msgSuffix}`,new AssertionError(msg)}__name(assertIsError,"assertIsError");function assertFalse(expr,msg=""){if(expr)throw new AssertionError(msg)}__name(assertFalse,"assertFalse");function assertNotInstanceOf(actual,unexpectedType,msg){let msgSuffix=msg?`: ${msg}`:".";msg=`Expected object to not be an instance of "${typeof unexpectedType}"${msgSuffix}`,assertFalse(actual instanceof unexpectedType,msg)}__name(assertNotInstanceOf,"assertNotInstanceOf");function assertMatch(actual,expected,msg){if(expected.test(actual))return;let msgSuffix=msg?`: ${msg}`:".";throw msg=`Expected actual: "${actual}" to match: "${expected}"${msgSuffix}`,new AssertionError(msg)}__name(assertMatch,"assertMatch");function isKeyedCollection2(x){return[Symbol.iterator,"size"].every(k=>k in x)}__name(isKeyedCollection2,"isKeyedCollection");function constructorsEqual2(a,b){return a.constructor===b.constructor||a.constructor===Object&&!b.constructor||!a.constructor&&b.constructor===Object}__name(constructorsEqual2,"constructorsEqual");function equal2(c,d){let seen=new Map;return __name(function compare(a,b){if(a&&b&&(a instanceof RegExp&&b instanceof RegExp||a instanceof URL&&b instanceof URL))return String(a)===String(b);if(a instanceof Date&&b instanceof Date){let aTime=a.getTime(),bTime=b.getTime();return Number.isNaN(aTime)&&Number.isNaN(bTime)?!0:aTime===bTime}if(typeof a=="number"&&typeof b=="number")return Number.isNaN(a)&&Number.isNaN(b)||a===b;if(Object.is(a,b))return!0;if(a&&typeof a=="object"&&b&&typeof b=="object"){if(a&&b&&!constructorsEqual2(a,b))return!1;if(a instanceof WeakMap||b instanceof WeakMap){if(!(a instanceof WeakMap&&b instanceof WeakMap))return!1;throw new TypeError("cannot compare WeakMap instances")}if(a instanceof WeakSet||b instanceof WeakSet){if(!(a instanceof WeakSet&&b instanceof WeakSet))return!1;throw new TypeError("cannot compare WeakSet instances")}if(a instanceof WeakRef||b instanceof WeakRef)return a instanceof WeakRef&&b instanceof WeakRef?compare(a.deref(),b.deref()):!1;if(seen.get(a)===b)return!0;if(Object.keys(a).length!==Object.keys(b).length)return!1;if(seen.set(a,b),isKeyedCollection2(a)&&isKeyedCollection2(b)){if(a.size!==b.size)return!1;let unmatchedEntries=a.size;for(let[aKey,aValue]of a.entries())for(let[bKey,bValue]of b.entries())if(aKey===aValue&&bKey===bValue&&compare(aKey,bKey)||compare(aKey,bKey)&&compare(aValue,bValue)){unmatchedEntries--;break}return unmatchedEntries===0}let merged={...a,...b};for(let key of[...Object.getOwnPropertyNames(merged),...Object.getOwnPropertySymbols(merged)])if(!compare(a&&a[key],b&&b[key])||key in a&&!(key in b)||key in b&&!(key in a))return!1;return!0}return!1},"compare")(c,d)}__name(equal2,"equal");function assertEquals(actual,expected,msg){if(equal2(actual,expected))return;let message=`Values are not equal${msg?`: ${msg}`:"."}`,actualString=format(actual),expectedString=format(expected),stringDiff=typeof actual=="string"&&typeof expected=="string",diffResult=stringDiff?diffStr(actual,expected):diff(actualString.split(`
`),expectedString.split(`
`)),diffMsg=buildMessage(diffResult,{stringDiff}).join(`
`);throw message=`${message}
${diffMsg}`,new AssertionError(message)}__name(assertEquals,"assertEquals");function assertObjectMatch(actual,expected,msg){return assertEquals(filter(actual,expected),filter(expected,expected),msg)}__name(assertObjectMatch,"assertObjectMatch");function isObject(val){return typeof val=="object"&&val!==null}__name(isObject,"isObject");function filter(a,b){let seen=new WeakMap;return filterObject(a,b);function filterObject(a2,b2){if(seen.has(a2)&&seen.get(a2)===b2)return a2;try{seen.set(a2,b2)}catch(err){if(err instanceof TypeError)throw new TypeError(`Cannot assertObjectMatch ${a2===null?null:`type ${typeof a2}`}`)}let filtered={},keysA=Reflect.ownKeys(a2),keysB=Reflect.ownKeys(b2),entries2=keysA.filter(key=>keysB.includes(key)).map(key=>[key,a2[key]]);if(keysA.length&&keysB.length&&!entries2.length){for(let key of keysA)filtered[key]=a2[key];return filtered}for(let[key,value]of entries2){if(value instanceof RegExp){filtered[key]=value;continue}let subset=b2[key];if(Array.isArray(value)&&Array.isArray(subset)){filtered[key]=filterArray(value,subset);continue}if(isObject(value)&&isObject(subset)){if(value instanceof Map&&subset instanceof Map){filtered[key]=new Map([...value].filter(([k])=>subset.has(k)).map(([k,v])=>{let v2=subset.get(k);return isObject(v)&&isObject(v2)?[k,filterObject(v,v2)]:[k,v]}));continue}if(value instanceof Set&&subset instanceof Set){filtered[key]=value.intersection(subset);continue}filtered[key]=filterObject(value,subset);continue}filtered[key]=value}return filtered}function filterArray(a2,b2){if(seen.has(a2)&&seen.get(a2)===b2)return a2;seen.set(a2,b2);let filtered=[],count=Math.min(a2.length,b2.length);for(let i=0;i<count;++i){let value=a2[i],subset=b2[i];if(value instanceof RegExp){filtered.push(value);continue}if(Array.isArray(value)&&Array.isArray(subset)){filtered.push(filterArray(value,subset));continue}if(isObject(value)&&isObject(subset)){if(value instanceof Map&&subset instanceof Map){let map=new Map([...value].filter(([k])=>subset.has(k)).map(([k,v])=>{let v2=subset.get(k);return isObject(v)&&isObject(v2)?[k,filterObject(v,v2)]:[k,v]}));filtered.push(map);continue}if(value instanceof Set&&subset instanceof Set){filtered.push(value.intersection(subset));continue}filtered.push(filterObject(value,subset));continue}filtered.push(value)}return filtered}}__name(filter,"filter");function assertNotMatch(actual,expected,msg){if(!expected.test(actual))return;let msgSuffix=msg?`: ${msg}`:".";throw msg=`Expected actual: "${actual}" to not match: "${expected}"${msgSuffix}`,new AssertionError(msg)}__name(assertNotMatch,"assertNotMatch");function isString(value){return typeof value=="string"}__name(isString,"isString");function buildEqualErrorMessage(actual,expected,options){let{formatter=format,msg}=options||{},msgSuffix=msg?`: ${msg}`:".",actualString=formatter(actual),expectedString=formatter(expected),message=`Values are not equal${msgSuffix}`,stringDiff=isString(actual)&&isString(expected),diffResult=stringDiff?diffStr(actual,expected):diff(actualString.split(`
`),expectedString.split(`
`)),diffMsg=buildMessage(diffResult,{stringDiff}).join(`
`);return message=`${message}
${diffMsg}`,message}__name(buildEqualErrorMessage,"buildEqualErrorMessage");function buildNotEqualErrorMessage(actual,expected,options){let{msg}=options||{},actualString=String(actual),expectedString=String(expected),msgSuffix=msg?`: ${msg}`:".";return`Expected actual: ${actualString} not to be: ${expectedString}${msgSuffix}`}__name(buildNotEqualErrorMessage,"buildNotEqualErrorMessage");function assertEquals2(actual,expected,options){if(equal(actual,expected,options))return;let message=buildEqualErrorMessage(actual,expected,options||{});throw new AssertionError(message)}__name(assertEquals2,"assertEquals");function assertNotEquals(actual,expected,options){let{msg}=options||{};if(!equal(actual,expected,options))return;let message=buildNotEqualErrorMessage(actual,expected,{msg});throw new AssertionError(message)}__name(assertNotEquals,"assertNotEquals");var MOCK_SYMBOL=Symbol.for("@MOCK");function getMockCalls(f){let mockInfo=f[MOCK_SYMBOL];if(!mockInfo)throw new Error("Received function must be a mock or spy function");return[...mockInfo.calls]}__name(getMockCalls,"getMockCalls");function inspectArgs(args){return args.map(inspectArg).join(", ")}__name(inspectArgs,"inspectArgs");function inspectArg(arg){let{Deno:Deno2}=globalThis;return typeof Deno2<"u"&&Deno2.inspect?Deno2.inspect(arg):String(arg)}__name(inspectArg,"inspectArg");function buildEqualOptions(options){let{customMessage,customTesters=[],strictCheck}=options||{};return{customTesters,msg:customMessage,strictCheck}}__name(buildEqualOptions,"buildEqualOptions");function isPromiseLike(value){return value==null?!1:typeof value.then=="function"}__name(isPromiseLike,"isPromiseLike");function hasIterator(object){return!!(object!=null&&object[Symbol.iterator])}__name(hasIterator,"hasIterator");function isA(typeName,value){return Object.prototype.toString.apply(value)===`[object ${typeName}]`}__name(isA,"isA");function isObject2(a){return a!==null&&typeof a=="object"}__name(isObject2,"isObject");function entries(obj){return isObject2(obj)?Object.getOwnPropertySymbols(obj).filter(key=>key!==Symbol.iterator).map(key=>[key,obj[key]]).concat(Object.entries(obj)):[]}__name(entries,"entries");function iterableEquality(a,b,customTesters=[],aStack=[],bStack=[]){if(typeof a!="object"||typeof b!="object"||Array.isArray(a)||Array.isArray(b)||!hasIterator(a)||!hasIterator(b))return;if(a.constructor!==b.constructor)return!1;let length=aStack.length;for(;length--;)if(aStack[length]===a)return bStack[length]===b;aStack.push(a),bStack.push(b);let iterableEqualityWithStack=__name((a2,b2)=>iterableEquality(a2,b2,[...filteredCustomTesters],[...aStack],[...bStack]),"iterableEqualityWithStack"),filteredCustomTesters=[...customTesters.filter(t=>t!==iterableEquality),iterableEqualityWithStack];if(a.size!==void 0){if(a.size!==b.size)return!1;if(isA("Set",a)){let allFound=!0;for(let aValue of a)if(!b.has(aValue)){let has=!1;for(let bValue of b)equal(aValue,bValue,{customTesters:filteredCustomTesters})===!0&&(has=!0);if(has===!1){allFound=!1;break}}return aStack.pop(),bStack.pop(),allFound}else if(isA("Map",a)){let allFound=!0;for(let aEntry of a)if(!b.has(aEntry[0])||!equal(aEntry[1],b.get(aEntry[0]),{customTesters:filteredCustomTesters})){let has=!1;for(let bEntry of b){let matchedKey=equal(aEntry[0],bEntry[0],{customTesters:filteredCustomTesters}),matchedValue=!1;matchedKey===!0&&(matchedValue=equal(aEntry[1],bEntry[1],{customTesters:filteredCustomTesters})),matchedValue===!0&&(has=!0)}if(has===!1){allFound=!1;break}}return aStack.pop(),bStack.pop(),allFound}}let bIterator=b[Symbol.iterator]();for(let aValue of a){let nextB=bIterator.next();if(nextB.done||!equal(aValue,nextB.value,{customTesters:filteredCustomTesters}))return!1}if(!bIterator.next().done)return!1;let aEntries=entries(a),bEntries=entries(b);return equal(aEntries,bEntries)?(aStack.pop(),bStack.pop(),!0):!1}__name(iterableEquality,"iterableEquality");function toBe(context,expect2){context.isNot?assertNotStrictEquals(context.value,expect2,context.customMessage):assertStrictEquals(context.value,expect2,context.customMessage)}__name(toBe,"toBe");function toEqual(context,expected){let v=context.value,e=expected,equalsOptions=buildEqualOptions({...context,customTesters:[...context.customTesters,iterableEquality]});context.isNot?assertNotEquals(v,e,equalsOptions):assertEquals2(v,e,equalsOptions)}__name(toEqual,"toEqual");function toStrictEqual(context,expected){let equalsOptions=buildEqualOptions({...context,strictCheck:!0,customTesters:[...context.customTesters,iterableEquality]});context.isNot?assertNotEquals(context.value,expected,equalsOptions):assertEquals2(context.value,expected,equalsOptions)}__name(toStrictEqual,"toStrictEqual");function toBeCloseTo(context,expected,numDigits=2){if(numDigits<0)throw new Error("toBeCloseTo second argument must be a non-negative integer. Got "+numDigits);let tolerance=.5*Math.pow(10,-numDigits),value=Number(context.value),pass=Math.abs(expected-value)<tolerance;if(context.isNot){if(pass)throw new AssertionError(`Expected the value not to be close to ${expected} (using ${numDigits} digits), but it is`)}else if(!pass)throw new AssertionError(`Expected the value (${value} to be close to ${expected} (using ${numDigits} digits), but it is not`)}__name(toBeCloseTo,"toBeCloseTo");function toBeDefined(context){context.isNot?assertStrictEquals(context.value,void 0,context.customMessage):assertNotStrictEquals(context.value,void 0,context.customMessage)}__name(toBeDefined,"toBeDefined");function toBeUndefined(context){context.isNot?assertNotStrictEquals(context.value,void 0,context.customMessage):assertStrictEquals(context.value,void 0,context.customMessage)}__name(toBeUndefined,"toBeUndefined");function toBeFalsy(context){let isFalsy=!context.value;if(context.isNot){if(isFalsy)throw new AssertionError(`Expected ${context.value} to NOT be falsy`)}else if(!isFalsy)throw new AssertionError(`Expected ${context.value} to be falsy`)}__name(toBeFalsy,"toBeFalsy");function toBeTruthy(context){let isTruthy=!!context.value;if(context.isNot){if(isTruthy)throw new AssertionError(`Expected ${context.value} to NOT be truthy`)}else if(!isTruthy)throw new AssertionError(`Expected ${context.value} to be truthy`)}__name(toBeTruthy,"toBeTruthy");function toBeGreaterThanOrEqual(context,expected){let isGreaterOrEqual=Number(context.value)>=Number(expected);if(context.isNot){if(isGreaterOrEqual)throw new AssertionError(`Expected ${context.value} to NOT be greater than or equal ${expected}`)}else if(!isGreaterOrEqual)throw new AssertionError(`Expected ${context.value} to be greater than or equal ${expected}`)}__name(toBeGreaterThanOrEqual,"toBeGreaterThanOrEqual");function toBeGreaterThan(context,expected){let isGreater=Number(context.value)>Number(expected);if(context.isNot){if(isGreater)throw new AssertionError(`Expected ${context.value} to NOT be greater than ${expected}`)}else if(!isGreater)throw new AssertionError(`Expected ${context.value} to be greater than ${expected}`)}__name(toBeGreaterThan,"toBeGreaterThan");function toBeInstanceOf(context,expected){context.isNot?assertNotInstanceOf(context.value,expected):assertInstanceOf(context.value,expected)}__name(toBeInstanceOf,"toBeInstanceOf");function toBeLessThanOrEqual(context,expected){let isLower=Number(context.value)<=Number(expected);if(context.isNot){if(isLower)throw new AssertionError(`Expected ${context.value} to NOT be lower than or equal ${expected}`)}else if(!isLower)throw new AssertionError(`Expected ${context.value} to be lower than or equal ${expected}`)}__name(toBeLessThanOrEqual,"toBeLessThanOrEqual");function toBeLessThan(context,expected){let isLower=Number(context.value)<Number(expected);if(context.isNot){if(isLower)throw new AssertionError(`Expected ${context.value} to NOT be lower than ${expected}`)}else if(!isLower)throw new AssertionError(`Expected ${context.value} to be lower than ${expected}`)}__name(toBeLessThan,"toBeLessThan");function toBeNaN(context){let equalsOptions=buildEqualOptions(context);context.isNot?assertNotEquals(isNaN(Number(context.value)),!0,{...equalsOptions,msg:equalsOptions.msg||`Expected ${context.value} to not be NaN`}):assertEquals2(isNaN(Number(context.value)),!0,{...equalsOptions,msg:equalsOptions.msg||`Expected ${context.value} to be NaN`})}__name(toBeNaN,"toBeNaN");function toBeNull(context){context.isNot?assertNotStrictEquals(context.value,null,context.customMessage||`Expected ${context.value} to not be null`):assertStrictEquals(context.value,null,context.customMessage||`Expected ${context.value} to be null`)}__name(toBeNull,"toBeNull");function toHaveLength(context,expected){let{value}=context,maybeLength=value?.length,hasLength=maybeLength===expected;if(context.isNot){if(hasLength)throw new AssertionError(`Expected value not to have length ${expected}, but it does`)}else if(!hasLength)throw new AssertionError(`Expected value to have length ${expected}, but it does not. (The value has length ${maybeLength})`)}__name(toHaveLength,"toHaveLength");function toHaveProperty(context,propName,v){let{value}=context,propPath=[];Array.isArray(propName)?propPath=propName:propPath=propName.split(".");let current=value;for(;!(current==null||propPath.length===0);){let prop=propPath.shift();current=current[prop]}let hasProperty;v?hasProperty=current!==void 0&&propPath.length===0&&equal(current,v,context):hasProperty=current!==void 0&&propPath.length===0;let ofValue="";if(v&&(ofValue=` of the value ${inspectArg(v)}`),context.isNot){if(hasProperty)throw new AssertionError(`Expected the value not to have the property ${propPath.join(".")}${ofValue}, but it does.`)}else if(!hasProperty)throw new AssertionError(`Expected the value to have the property ${propPath.join(".")}${ofValue}, but it does not.`)}__name(toHaveProperty,"toHaveProperty");function toContain(context,expected){let doesContain=context.value?.includes?.(expected),fmtValue=format(context.value),fmtExpected=format(expected);if(context.isNot){if(doesContain)throw new AssertionError(`The value ${fmtValue} contains the expected item ${fmtExpected}`)}else if(!doesContain)throw new AssertionError(`The value ${fmtValue} doesn't contain the expected item ${fmtExpected}`)}__name(toContain,"toContain");function toContainEqual(context,expected){let{value}=context;assertIsIterable(value);let doesContain=!1;for(let item of value)if(equal(item,expected,context)){doesContain=!0;break}let prettyStringify=__name(js=>JSON.stringify(js,null,"	").replace(/\"|\n|\t/g,"").slice(0,100),"prettyStringify"),fmtValue=prettyStringify(context.value),fmtExpected=prettyStringify(expected);if(context.isNot){if(doesContain)throw new AssertionError(`The value contains the expected item.
Value: ${fmtValue}
Expected: ${fmtExpected}`)}else if(!doesContain)throw new AssertionError(`The value doesn't contain the expected item.
Value: ${fmtValue}
Expected: ${fmtExpected}`)}__name(toContainEqual,"toContainEqual");function assertIsIterable(value){if(value==null)throw new AssertionError("The value is null or undefined");if(typeof value[Symbol.iterator]!="function")throw new AssertionError("The value is not iterable")}__name(assertIsIterable,"assertIsIterable");function toMatch(context,expected){context.isNot?assertNotMatch(String(context.value),expected,context.customMessage):assertMatch(String(context.value),expected,context.customMessage)}__name(toMatch,"toMatch");function toMatchObject(context,expected){if(context.isNot){let objectMatch=!1;try{assertObjectMatch(context.value,expected,context.customMessage),objectMatch=!0;let actualString=format(context.value),expectedString=format(expected);throw new AssertionError(`Expected ${actualString} to NOT match ${expectedString}`)}catch(e){if(objectMatch)throw e;return}}else assertObjectMatch(context.value,expected,context.customMessage)}__name(toMatchObject,"toMatchObject");function toHaveBeenCalled(context){let calls=getMockCalls(context.value),hasBeenCalled=calls.length>0;if(context.isNot){if(hasBeenCalled)throw new AssertionError(`Expected mock function not to be called, but it was called ${calls.length} time(s)`)}else if(!hasBeenCalled)throw new AssertionError("Expected mock function to be called, but it was not called")}__name(toHaveBeenCalled,"toHaveBeenCalled");function toHaveBeenCalledTimes(context,expected){let calls=getMockCalls(context.value);if(context.isNot){if(calls.length===expected)throw new AssertionError(`Expected mock function not to be called ${expected} time(s), but it was`)}else if(calls.length!==expected)throw new AssertionError(`Expected mock function to be called ${expected} time(s), but it was called ${calls.length} time(s)`)}__name(toHaveBeenCalledTimes,"toHaveBeenCalledTimes");function toHaveBeenCalledWith(context,...expected){let calls=getMockCalls(context.value),hasBeenCalled=calls.some(call=>equal(call.args,expected));if(context.isNot){if(hasBeenCalled)throw new AssertionError(`Expected mock function not to be called with ${inspectArgs(expected)}, but it was`)}else if(!hasBeenCalled){let otherCalls="";throw calls.length>0&&(otherCalls=`
  Other calls:
     ${calls.map(call=>inspectArgs(call.args)).join(`
    `)}`),new AssertionError(`Expected mock function to be called with ${inspectArgs(expected)}, but it was not.${otherCalls}`)}}__name(toHaveBeenCalledWith,"toHaveBeenCalledWith");function toHaveBeenLastCalledWith(context,...expected){let calls=getMockCalls(context.value),hasBeenCalled=calls.length>0&&equal(calls.at(-1)?.args,expected);if(context.isNot){if(hasBeenCalled)throw new AssertionError(`Expected mock function not to be last called with ${inspectArgs(expected)}, but it was`)}else if(!hasBeenCalled){let lastCall=calls.at(-1);throw lastCall?new AssertionError(`Expected mock function to be last called with ${inspectArgs(expected)}, but it was last called with ${inspectArgs(lastCall.args)}.`):new AssertionError(`Expected mock function to be last called with ${inspectArgs(expected)}, but it was not.`)}}__name(toHaveBeenLastCalledWith,"toHaveBeenLastCalledWith");function toHaveBeenNthCalledWith(context,nth,...expected){if(nth<1)throw new Error(`nth must be greater than 0. ${nth} was given.`);let calls=getMockCalls(context.value),callIndex=nth-1,hasBeenCalled=calls.length>callIndex&&equal(calls[callIndex]?.args,expected);if(context.isNot){if(hasBeenCalled)throw new AssertionError(`Expected the n-th call (n=${nth}) of mock function is not with ${inspectArgs(expected)}, but it was`)}else if(!hasBeenCalled){let nthCall=calls[callIndex];throw nthCall?new AssertionError(`Expected the n-th call (n=${nth}) of mock function is with ${inspectArgs(expected)}, but it was with ${inspectArgs(nthCall.args)}.`):new AssertionError(`Expected the n-th call (n=${nth}) of mock function is with ${inspectArgs(expected)}, but the n-th call does not exist.`)}}__name(toHaveBeenNthCalledWith,"toHaveBeenNthCalledWith");function toHaveReturned(context){let returned=getMockCalls(context.value).filter(call=>call.returns);if(context.isNot){if(returned.length>0)throw new AssertionError(`Expected the mock function to not have returned, but it returned ${returned.length} times`)}else if(returned.length===0)throw new AssertionError("Expected the mock function to have returned, but it did not return")}__name(toHaveReturned,"toHaveReturned");function toHaveReturnedTimes(context,expected){let returned=getMockCalls(context.value).filter(call=>call.returns);if(context.isNot){if(returned.length===expected)throw new AssertionError(`Expected the mock function to not have returned ${expected} times, but it returned ${returned.length} times`)}else if(returned.length!==expected)throw new AssertionError(`Expected the mock function to have returned ${expected} times, but it returned ${returned.length} times`)}__name(toHaveReturnedTimes,"toHaveReturnedTimes");function toHaveReturnedWith(context,expected){let returnedWithExpected=getMockCalls(context.value).filter(call=>call.returns).some(call=>equal(call.returned,expected));if(context.isNot){if(returnedWithExpected)throw new AssertionError(`Expected the mock function to not have returned with ${inspectArg(expected)}, but it did`)}else if(!returnedWithExpected)throw new AssertionError(`Expected the mock function to have returned with ${inspectArg(expected)}, but it did not`)}__name(toHaveReturnedWith,"toHaveReturnedWith");function toHaveLastReturnedWith(context,expected){let returned=getMockCalls(context.value).filter(call=>call.returns),lastReturnedWithExpected=returned.length>0&&equal(returned.at(-1)?.returned,expected);if(context.isNot){if(lastReturnedWithExpected)throw new AssertionError(`Expected the mock function to not have last returned with ${inspectArg(expected)}, but it did`)}else if(!lastReturnedWithExpected)throw new AssertionError(`Expected the mock function to have last returned with ${inspectArg(expected)}, but it did not`)}__name(toHaveLastReturnedWith,"toHaveLastReturnedWith");function toHaveNthReturnedWith(context,nth,expected){if(nth<1)throw new Error(`nth(${nth}) must be greater than 0`);let returned=getMockCalls(context.value).filter(call=>call.returns),returnIndex=nth-1,maybeNthReturned=returned[returnIndex],nthReturnedWithExpected=maybeNthReturned&&equal(maybeNthReturned.returned,expected);if(context.isNot){if(nthReturnedWithExpected)throw new AssertionError(`Expected the mock function to not have n-th (n=${nth}) returned with ${inspectArg(expected)}, but it did`)}else if(!nthReturnedWithExpected)throw new AssertionError(`Expected the mock function to have n-th (n=${nth}) returned with ${inspectArg(expected)}, but it did not`)}__name(toHaveNthReturnedWith,"toHaveNthReturnedWith");function toThrow(context,expected){if(typeof context.value=="function")try{context.value=context.value()}catch(err){context.value=err}let expectClass,expectMessage;if(expected instanceof Error&&(expectClass=expected.constructor,expectMessage=expected.message),expected instanceof Function&&(expectClass=expected),(typeof expected=="string"||expected instanceof RegExp)&&(expectMessage=expected),context.isNot){let isError=!1;try{throw assertIsError(context.value,expectClass,expectMessage,context.customMessage),isError=!0,new AssertionError(`Expected to NOT throw ${expected}`)}catch(e){if(isError)throw e;return}}return assertIsError(context.value,expectClass,expectMessage,context.customMessage)}__name(toThrow,"toThrow");var matchers={lastCalledWith:toHaveBeenLastCalledWith,lastReturnedWith:toHaveLastReturnedWith,nthCalledWith:toHaveBeenNthCalledWith,nthReturnedWith:toHaveNthReturnedWith,toBeCalled:toHaveBeenCalled,toBeCalledTimes:toHaveBeenCalledTimes,toBeCalledWith:toHaveBeenCalledWith,toBeCloseTo,toBeDefined,toBeFalsy,toBeGreaterThanOrEqual,toBeGreaterThan,toBeInstanceOf,toBeLessThanOrEqual,toBeLessThan,toBeNaN,toBeNull,toBeTruthy,toBeUndefined,toBe,toContainEqual,toContain,toEqual,toHaveBeenCalledTimes,toHaveBeenCalledWith,toHaveBeenCalled,toHaveBeenLastCalledWith,toHaveBeenNthCalledWith,toHaveLength,toHaveLastReturnedWith,toHaveNthReturnedWith,toHaveProperty,toHaveReturnedTimes,toHaveReturnedWith,toHaveReturned,toMatchObject,toMatch,toReturn:toHaveReturned,toReturnTimes:toHaveReturnedTimes,toReturnWith:toHaveReturnedWith,toStrictEqual,toThrow};function expect(value,customMessage){let isNot=!1,isPromised=!1,self=new Proxy({},{get(_,name){if(name==="not")return isNot=!isNot,self;if(name==="resolves"){if(!isPromiseLike(value))throw new AssertionError("expected value must be Promiselike");return isPromised=!0,self}if(name==="rejects"){if(!isPromiseLike(value))throw new AssertionError("expected value must be a PromiseLike");return value=value.then(value2=>{throw new AssertionError(`Promise did not reject. resolved to ${value2}`)},err=>err),isPromised=!0,self}let extendMatchers2=getExtendMatchers(),matcher={...extendMatchers2,...matchers}[name];if(!matcher)throw new TypeError(typeof name=="string"?`matcher not found: ${name}`:"matcher not found");return(...args)=>{function applyMatcher(value2,args2){let context={value:value2,equal,isNot:!1,customMessage,customTesters:getCustomEqualityTesters()};if(isNot&&(context.isNot=!0),name in extendMatchers2){let result=matcher(context,...args2);if(context.isNot){if(result.pass)throw new AssertionError(result.message())}else if(!result.pass)throw new AssertionError(result.message())}else matcher(context,...args2)}return __name(applyMatcher,"applyMatcher"),isPromised?value.then(value2=>applyMatcher(value2,args)):applyMatcher(value,args)}}});return self}__name(expect,"expect");expect.addEqualityTesters=addCustomEqualityTesters;expect.extend=setExtendMatchers;expect.anything=anything;expect.any=any;expect.arrayContaining=arrayContaining;expect.closeTo=closeTo;expect.stringContaining=stringContaining;expect.stringMatching=stringMatching;var isArray=Array.isArray;function isIterable(value){return typeof value?.[Symbol.iterator]=="function"}__name(isIterable,"isIterable");function isAsyncIterable(value){return typeof value?.[Symbol.asyncIterator]=="function"}__name(isAsyncIterable,"isAsyncIterable");function isMaybeAsyncIterable(value){return typeof value?.[Symbol.iterator]=="function"||typeof value?.[Symbol.asyncIterator]=="function"}__name(isMaybeAsyncIterable,"isMaybeAsyncIterable");async function partitionArrAsync(predicate,arrayLike){let yes=[],no=[];for await(let i of arrayLike)await predicate(i)?yes.push(i):no.push(i);return[yes,no]}__name(partitionArrAsync,"partitionArrAsync");async function*entriesArrayLikeAsync(arrayLike){let i=0;for await(let arrayLikeElement of arrayLike)yield[i,arrayLikeElement],i++}__name(entriesArrayLikeAsync,"entriesArrayLikeAsync");import{configure,getLogger as getLogger2}from"@logtape/logtape";import{getConsoleSink,getFileSink,getLevelFilter,withFilter}from"@logtape/logtape";function logtapeConfiguration(appName="monochromatic"){return{sinks:{console:getConsoleSink(),consoleInfoPlus:withFilter(getConsoleSink(),getLevelFilter("info")),consoleWarnPlus:withFilter(getConsoleSink(),getLevelFilter("warning")),file:getFileSink(`${appName}.log`,{formatter(log){return`${JSON.stringify(log,null,2)}
`}})},filters:{},loggers:[{category:["a"],level:"debug",sinks:["file","consoleInfoPlus"]},{category:["t"],level:"debug",sinks:["file","consoleInfoPlus"]},{category:["m"],level:"debug",sinks:["file","consoleWarnPlus"]},{category:["esbuild-plugin"],level:"debug",sinks:["file","consoleWarnPlus"]},{category:["logtape","meta"],level:"warning",sinks:["console"]}]}}__name(logtapeConfiguration,"logtapeConfiguration");import{getLogger}from"@logtape/logtape";var l=getLogger(["t","m"]);async function suite(name,testOrSuites,options){l.debug`suite ${name} started: ${testOrSuites.length} tests or suites`;let result=await Promise.allSettled(testOrSuites);if(options){if(Object.hasOwn(options,"skip"))return{name,skip:options.skip};if(Object.hasOwn(options,"todo"))return l.info`suite ${name} finished: ${result}`,{name,todo:options.todo,result}}if(result.some(settledResult=>settledResult.status==="rejected"))throw new Error(`suite ${name} errored: ${result}`);return l.info`suite ${name} finished: ${result}`,{name,result}}__name(suite,"suite");async function test(name,callback,options){let timeLimit=0,took=0;if(options){if(Object.hasOwn(options,"skip"))return l.warn`${name} skipped: ${options.skip}`,{name,skip:options.skip};if(Object.hasOwn(options,"timeLimit")&&(timeLimit=typeof options.timeLimit=="number"?options.timeLimit:await(async()=>{let beforeExecutingTimeLimitReferenceCallback=performance.now();return await options.timeLimit(),performance.now()-beforeExecutingTimeLimitReferenceCallback})(),l.debug`${name} timeLimit: ${timeLimit}ms`),Object.hasOwn(options,"todo")){l.info`${name} started: ${String(callback).slice(0,64)} with todo: ${options.todo}`;try{let beforeExecutingTestingCallback=performance.now(),result2=await callback();if(took=performance.now()-beforeExecutingTestingCallback,l.debug`${name} took: ${took}ms`,result2!=null){if(took>timeLimit){let tooLongPercentage=100*(took-timeLimit)/timeLimit;return l.error`${name} with todo: ${options.todo} took: ${took}ms, ${took-timeLimit}ms longer than timeLimit: ${timeLimit}ms, that's ${tooLongPercentage}% too long. finished: ${result2}`,{name,todo:options.todo,result:result2,tooLongPercentage}}return l.warn`${name} with todo: ${options.todo} finished: ${result2}`,{name,todo:options.todo,result:result2}}if(took>timeLimit){let tooLongPercentage=100*(took-timeLimit)/timeLimit;return l.error`${name} with todo: ${options.todo} took: ${took}ms, ${took-timeLimit}ms longer than timeLimit: ${timeLimit}ms, that's ${tooLongPercentage}% too long.`,{name,todo:options.todo,tooLongPercentage}}return l.warn`${name} with todo: ${options.todo} finished`,{name,todo:options.todo}}catch(e){return l.error`${name} with todo: ${options.todo} errored: ${e}`,{name,todo:options.todo,result:e}}}}l.debug`${name} started: ${String(callback).slice(0,64)}`;let result=await callback();if(took>timeLimit){let tooLongPercentage=100*(took-timeLimit)/timeLimit;throw new Error(`${name} took: ${took}ms, ${took-timeLimit}ms longer than timeLimit: ${timeLimit}ms, that's ${tooLongPercentage}% too long. finished: ${result}`)}return result!=null?(l.info`${name} finished: ${result}`,{name,result}):(l.info`${name} finished`,name)}__name(test,"test");await configure(logtapeConfiguration());var l2=getLogger2(["t","arrayLike"]);suite("partitionArrAsync (deprecated)",[suite("arr",[test("empty",async()=>{expect(await partitionArrAsync(()=>!0,[])).toStrictEqual([[],[]])}),test("true",async()=>{expect(await partitionArrAsync(()=>!0,[1])).toStrictEqual([[1],[]])}),test("false",async()=>{expect(await partitionArrAsync(()=>!1,[1])).toStrictEqual([[],[1]])}),test("mixed",async()=>{expect(await partitionArrAsync(Boolean,[0,1])).toStrictEqual([[1],[0]])})]),suite("generator",[test("empty",async()=>{expect(await partitionArrAsync(()=>!0,function*(){}())).toStrictEqual([[],[]])}),test("true",async()=>{expect(await partitionArrAsync(()=>!0,function*(){yield 1}())).toStrictEqual([[1],[]])}),test("false",async()=>{expect(await partitionArrAsync(()=>!1,function*(){yield 1}())).toStrictEqual([[],[1]])}),test("mixed",async()=>{expect(await partitionArrAsync(Boolean,function*(){yield 0,yield 1}())).toStrictEqual([[1],[0]])})]),suite("AsyncGenerator",[test("empty",async()=>{expect(await partitionArrAsync(async()=>!0,async function*(){}())).toStrictEqual([[],[]])}),test("true",async()=>{expect(await partitionArrAsync(async()=>!0,async function*(){yield 1}())).toStrictEqual([[1],[]])}),test("false",async()=>{expect(await partitionArrAsync(async()=>!1,async function*(){yield 1}())).toStrictEqual([[],[1]])}),test("mixed",async()=>{expect(await partitionArrAsync(async i=>!!i,async function*(){yield 0,yield 1}())).toStrictEqual([[1],[0]])})])]);suite("isIterable",[test("Array",()=>{expect(isIterable([])).toStrictEqual(!0)}),test("string",()=>{expect(isIterable("")).toStrictEqual(!0)}),test("Iterable",()=>{expect(isIterable(function*(){}())).toStrictEqual(!0)}),test("AsyncIterable - false",()=>{expect(isIterable(async function*(){}())).toStrictEqual(!1)})]);suite("isAsyncIterable",[test("Array - false",()=>{expect(isAsyncIterable([])).toStrictEqual(!1)}),test("string - false",()=>{expect(isAsyncIterable("")).toStrictEqual(!1)}),test("Iterable - false",()=>{expect(isAsyncIterable(function*(){}())).toStrictEqual(!1)}),test("AsyncIterable",()=>{expect(isAsyncIterable(async function*(){}())).toStrictEqual(!0)})]);suite("isMaybeAsyncIterable",[test("Array",()=>{expect(isMaybeAsyncIterable([])).toStrictEqual(!0)}),test("string",()=>{expect(isMaybeAsyncIterable("")).toStrictEqual(!0)}),test("Iterable",()=>{expect(isMaybeAsyncIterable(function*(){}())).toStrictEqual(!0)}),test("AsyncIterable",()=>{expect(isMaybeAsyncIterable(async function*(){}())).toStrictEqual(!0)})]);suite("entriesArrayLikeAsync",[suite("Array",[test("empty",async()=>{let entries2=[];for await(let entry of entriesArrayLikeAsync([]))entries2.push(entry);expect(entries2).toStrictEqual([])}),test("one",async()=>{let entries2=[];for await(let entry of entriesArrayLikeAsync([1]))entries2.push(entry);expect(entries2).toStrictEqual([[0,1]])}),test("holey",async()=>{let entries2=[];for await(let entry of entriesArrayLikeAsync([1,,2]))entries2.push(entry);expect(entries2).toStrictEqual([[0,1],[1,void 0],[2,2]])})]),suite("Iterable",[])]);
