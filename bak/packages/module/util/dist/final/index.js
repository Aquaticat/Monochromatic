var Te=Object.defineProperty;var t=(e,n)=>Te(e,"name",{value:n,configurable:!0});async function*V(e){let n=0;for await(let r of e)yield[n,r],n++}t(V,"entriesArrayLikeAsync");function*H(e){let n=0;for(let r of e)yield[n,r],n++}t(H,"entriesArrayLike");async function Ee(e,n){if(Array.isArray(n))return n.at(e);let r=[];for await(let[i,s]of V(n)){if(i===e)return s;r.push(s)}return r.at(e)}t(Ee,"atArrayLikeAsync");function Ne(e,n){if(Array.isArray(n))return n.at(e);let r=[];for(let[i,s]of H(n)){if(i===e)return s;r.push(s)}return r.at(e)}t(Ne,"atArrayLike");import{getLogger as oe}from"@logtape/logtape";var A=oe(["m","arrayLike.chunks"]);function*Q(e,n){if(I(e))throw new RangeError("What's to be chunked cannot be empty");if(n>e.length)throw new RangeError("Initial chunk index is already out of range.");for(let r=0;r<e.length;r+=n)yield e.slice(r,r+n)}t(Q,"chunksArray");function*Oe(e,n){if(A.debug`chunksArrayLike(arrayLike: ${e}, n: ${n})`,typeof e?.length=="number"){if(v(e))throw new RangeError(`What's to be chunked: ${JSON.stringify(e)} cannot be empty`);if(n>e.length)throw new RangeError(`Initial chunk index: ${n} is already out of range: ${e.length}`);A.debug`arrayLike.length: ${e.length}, n: ${n}`}let r=c(e);if(A.debug`arrayLikeArray: ${r}`,n>r.length)throw new RangeError(`Initial chunk index: ${n} is already out of range: ${r.length}`);if(I(r))throw new RangeError(`What's to be chunked: ${JSON.stringify(r)} cannot be empty`);if(M(r)){yield*Q(r,n);return}throw new Error(`impossible state. ${r} is neither empty nor non-empty`)}t(Oe,"chunksArrayLike");async function*je(e,n){if(A.debug`chunksArrayLikeAsync(arrayLike: ${e}, n: ${n})`,typeof e?.length=="number"){if(v(e))throw new RangeError(`What's to be chunked: ${JSON.stringify(e)} cannot be empty`);if(n>e.length)throw new RangeError(`Initial chunk index: ${n} is already out of range: ${e.length}`);A.debug`arrayLike.length: ${e.length}, n: ${n}`}let r=await d(e);if(A.debug`arrayLikeArray: ${r}`,n>r.length)throw new RangeError(`Initial chunk index: ${n} is already out of range: ${r.length}`);if(I(r))throw new RangeError(`What's to be chunked: ${JSON.stringify(r)} cannot be empty`);if(M(r)){yield*Q(r,n);return}throw new Error(`impossible state. ${r} is neither empty nor non-empty`)}t(je,"chunksArrayLikeAsync");var w=Array.isArray;function We(e){return typeof e?.[Symbol.iterator]=="function"}t(We,"isIterable");function g(e){return typeof e?.[Symbol.asyncIterator]=="function"}t(g,"isAsyncIterable");function Be(e){return typeof e?.[Symbol.iterator]=="function"||typeof e?.[Symbol.asyncIterator]=="function"}t(Be,"isMaybeAsyncIterable");function S(e){return Object.prototype.toString.call(e)==="[object Map]"}t(S,"isMap");function O(e){return Object.prototype.toString.call(e)==="[object WeakMap]"}t(O,"isWeakMap");function j(e){return Object.prototype.toString.call(e)==="[object Set]"}t(j,"isSet");function F(e){return Object.prototype.toString.call(e)==="[object WeakSet]"}t(F,"isWeakSet");function G(e){return Object.prototype.toString.call(e)==="[object Object]"}t(G,"isObject");function R(e){return Object.prototype.toString.call(e)==="[object AsyncGenerator]"}t(R,"isAsyncGenerator");function W(e){return Object.prototype.toString.call(e)==="[object Generator]"}t(W,"isGenerator");function v(e){return w(e)&&e.length===0}t(v,"isEmptyArray");function I(e){return e.length===0}t(I,"arrayIsEmpty");function Ue(e){return w(e)&&e.length!==0}t(Ue,"isNonEmptyArray");function M(e){return w(e)&&e.length!==0}t(M,"arrayIsNonEmpty");async function d(e,n){let r=w(e)?e:await(async a=>{let _=[];for await(let p of a)_.push(p);return _})(e);if(!n)return r;let i=[],s=0;for(let a of r)i.push(n(a,s)),s++;return await Promise.all(i)}t(d,"arrayFromAsync");function c(e,n){let r=w(e)?e:(a=>{let _=[];for(let p of a)_.push(p);return _})(e);if(!n)return r;let i=[],s=0;for(let a of r)i.push(n(a,s)),s++;return i}t(c,"arrayFrom");async function k(e,n){return await d(n,e)}t(k,"mapArrayLikeAsync");function $(e,n){return c(n,e)}t($,"mapArrayLike");import{getLogger as Pe}from"@logtape/logtape";async function b(e,n){await Z(e)(n)}t(b,"assertAsync");async function Qe(e){await b(!0,await e)}t(Qe,"assertTrueAsync");async function Ze(e){await b(!1,await e)}t(Ze,"assertFalseAsync");async function Ke(e){await b(void 0,e)}t(Ke,"assertUndefinedAsync");async function en(e){await b(null,e)}t(en,"assertNullAsync");async function nn(e){await b([],e)}t(nn,"assertEmptyArrayAsync");async function tn(e){await b({},e)}t(tn,"assertEmptyObjectAsync");async function rn(e){await b(0,e)}t(rn,"assert0Async");async function sn(e){await b(1,e)}t(sn,"assert1Async");async function an(e){await b(Number.NaN,e)}t(an,"assertNanAsync");async function Tn(e){await b(-1,e)}t(Tn,"assertNegative1Async");function P(e,n){h(e)(n)}t(P,"assert");function on(e){}t(on,"assertTrue");function _n(e){}t(_n,"assertFalse");function un(e){}t(un,"assertUndefined");function pn(e){}t(pn,"assertNull");function fn(e){}t(fn,"assertEmptyArray");function yn(e){}t(yn,"assertEmptyObject");function mn(e){}t(mn,"assert0");function cn(e){}t(cn,"assert1");function ln(e){Number.NaN}t(ln,"assertNan");function dn(e){}t(dn,"assertNegative1");import{getLogger as _e}from"@logtape/logtape";var K=_e(["m","error.assert.throw"]);async function L(e,n){try{await n()}catch(r){if(K.debug`assertThrowAsync(error: ${e}, fn: ${String(n)}), actualError: ${String(r)}`,typeof e=="function"){if(!(r instanceof e))throw new Error(`actualError ${r} does not match error: ${e}`);return}let i=h(e);if(e instanceof Error){i(r);return}if(typeof e!="string")throw new Error(`unexpected type ${typeof e} of expected error: ${e}`);if(e==="Error"){if(!(r instanceof Error))throw new Error(`actualError ${r} is not an Error`);return}if(e.endsWith("Error")){i(r?.name);return}i(r.message);return}throw new Error(`fn ${n} unexpectedly didn't throw`)}t(L,"assertThrowAsync");function E(e,n){try{n()}catch(r){if(K.debug`assertThrow(error: ${e}, fn: ${String(n)}), actualError: ${String(r)}`,typeof e=="function"){if(!(r instanceof e))throw new Error(`actualError ${r} does not match error: ${e}`);return}let i=h(e);if(e instanceof Error){i(r);return}if(typeof e!="string")throw new Error(`unexpected type ${typeof e} of expected error: ${e}`);if(e==="Error"){if(!(r instanceof Error))throw new Error(`actualError ${r} is not an Error`);return}if(e.endsWith("Error")){i(r?.name);return}i(r.message);return}throw new Error(`fn ${n} unexpectedly didn't throw`)}t(E,"assertThrow");async function gn(e){await L("Error",e)}t(gn,"assertThrowErrorAsync");async function Rn(e){await L("TypeError",e)}t(Rn,"assertThrowTypeErrorAsync");async function kn(e){await L("RangeError",e)}t(kn,"assertThrowRangeErrorAsync");async function hn(e){await L("ReferenceError",e)}t(hn,"assertThrowReferenceErrorAsync");async function Ln(e){await L("URIError",e)}t(Ln,"assertThrowURIErrorAsync");function En(e){}t(En,"assertThrowError");function Nn(e){}t(Nn,"assertThrowTypeError");function In(e){}t(In,"assertThrowRangeError");function $n(e){}t($n,"assertThrowReferenceError");function vn(e){}t(vn,"assertThrowURIError");function B(e){return Object.prototype.toString.call(e)==="[object Error]"}t(B,"isError");function Fn(e){if(e===null||typeof e>"u")throw new TypeError(`${e} is nullish`);return e}t(Fn,"notNullishOrThrow");function Gn(e){if(typeof e>"u")throw new TypeError(`${e} is undefined`);return e}t(Gn,"notUndefinedOrThrow");function Wn(e){if(e===null)throw new TypeError(`${e} is null`);return e}t(Wn,"notNullOrThrow");function Bn(e){if(!e)throw new TypeError(`${e} is null`);return e}t(Bn,"notFalsyOrThrow");function Un(e){if(e===!1)throw new TypeError(`${e} is false`);return e}t(Un,"notFalseOrThrow");import{getLogger as ue}from"@logtape/logtape";var pe=ue(["m","error.throws"]);function zn(e){if(e instanceof Error)throw e;if(typeof e=="string")throw new Error(e);if(!e.name)throw e.cause?new Error(e.message,{cause:e.cause}):new Error(e.message);switch(e.name){case"Error":throw e.cause?new Error(e.message,{cause:e.cause}):new Error(e.message);case"RangeError":throw e.cause?new RangeError(e.message,{cause:e.cause}):new RangeError(e.message);case"ReferenceError":throw e.cause?new ReferenceError(e.message,{cause:e.cause}):new ReferenceError(e.message);case"TypeError":throw e.cause?new TypeError(e.message,{cause:e.cause}):new TypeError(e.message);case"URIError":throw e.cause?new URIError(e.message,{cause:e.cause}):new URIError(e.message);default:throw pe.warn`error.name ${e.name} not one of:
      throwableErrors = ['Error', 'RangeError', 'ReferenceError', 'TypeError', 'URIError']
      This function doesn't handle custom error types.
      Pass in a custom error to throw it.`,e.cause?new Error(`${e.name}: ${e.message}`,{cause:e.cause}):new Error(`${e.name}: ${e.message}`)}}t(zn,"throws");async function Yn(...e){let n=0;for await(let r of e)n+=r;return n}t(Yn,"addNumbersAsync");function Vn(...e){let n=0;for(let r of e)n+=r;return n}t(Vn,"addNumbers");async function Hn(...e){let n=0n;for await(let r of e)n+=r;return n}t(Hn,"addBigintsAsync");function Qn(...e){let n=0n;for(let r of e)n+=r;return n}t(Qn,"addBigints");async function Zn(...e){let n=0;for await(let r of e){if(typeof r=="bigint"&&typeof n!="bigint"){n=BigInt(n)+r;continue}n+=r}return n}t(Zn,"addNumericsAsync");function Kn(...e){let n=0;for(let r of e){if(typeof r=="bigint"&&typeof n!="bigint"){n=BigInt(n)+r;continue}n+=r}return n}t(Kn,"addNumerics");function fe(e){return typeof e=="number"}t(fe,"isNumber");function ye(e){return Number.isNaN(e)}t(ye,"isNan");function tt(e){return Number.isInteger(e)}t(tt,"isInteger");function rt(e){return me(e)&&!Number.isInteger(e)}t(rt,"isFloat");function me(e){return fe(e)&&!ye(e)}t(me,"isNonNanNumber");function ee(e){return e===Number.POSITIVE_INFINITY}t(ee,"isPositiveInfinity");function ce(e){return e===Number.POSITIVE_INFINITY}t(ce,"isNegativeInfinity");function le(e){return ee(e)||ce(e)}t(le,"isInfinity");function de(e){return!le(e)}t(de,"isFinite");function xe(e){return de(e)&&Number.MAX_SAFE_INTEGER<=e&&e<=Number.MAX_SAFE_INTEGER}t(xe,"isSafeNumber");function it(e){return ee(e)||xe(e)}t(it,"isPositiveNumber");function U(e){return Object.prototype.toString.call(e)==="[object Date]"}t(U,"isObjectDate");async function Tt(e){return await e}t(Tt,"awaits");function N(e){return typeof e?.then=="function"}t(N,"isPromise");import{getLogger as be}from"@logtape/logtape";var ne=be(["m","promise.some"]);async function q(e,n){if(w(n))try{return await Promise.any($(t(async function(s){let a=await s,_=await e(a);if(!_)throw new Error(`callback ${String(e)} evals to false for ${a}`);return _},"callbackThrowing"),n))}catch(r){return ne.info`${r}`,!1}for await(let r of n)try{return await e(r),!0}catch(i){ne.info`${i}`}return!1}t(q,"somePromises");function xt(...e){return e.join("")}t(xt,"concatStrings");function te(e){return typeof e=="string"}t(te,"isString");function C(e){return Object.prototype.toString.call(e)==="[object RegExp]"}t(C,"isRegexp");async function gt(e,n){if(Array.isArray(n))return n.join(e);let r=[];for await(let i of n)r.push(i);return r.join(e)}t(gt,"joinStringsAsync");function Rt(e,n){if(Array.isArray(n))return n.join(e);let r=[];for(let i of n)r.push(i);return r.join(e)}t(Rt,"joinStrings");var u=Pe(["m","boolean.equal"]);function re(e){return Object.is(e,void 0)||Object.is(e,null)||typeof e=="boolean"||te(e)||typeof e=="bigint"||Object.prototype.toString.call(e)==="[object BigInt]"||typeof e=="symbol"||typeof e=="number"?!0:(u.debug`value ${e} is not a primitive`,!1)}t(re,"isPrimitive");function l(e,n){if(u.debug`a: ${String(e)}, b: ${String(n)}`,Object.is(e,n))return!0;if(u.debug`ref/primitive eq failed on a: ${String(e)}, b: ${String(n)}`,re(e)||re(n))return u.debug`At least one of a: ${String(e)} and b: ${String(n)} is primitive`,!1;if(u.debug`non-primitives a: ${e}, b: ${n}`,N(e)||N(n))throw new TypeError(`At least one of a: ${e} and b: ${n} is a thenable.
      We cannot handle comparing them in a sync function.
      Try equalAsync()`);if(typeof e=="function")return typeof n!="function"?(u.info`Is it intentional trying to compare a function a: ${e} to not function b: ${n}?`,!1):(u.warn`cannot compare two functions accurately due to the inherent unpredictability of functions.
    See https://stackoverflow.com/a/32061834 by https://stackoverflow.com/users/1742789/julian-de-bhal
    The string representations of both functions are not normalized before comparison.
    Nor were the functions converted to there AST form.
    Therefore, this comparison has a high chance of giving a false negative or false positive.
    `,`${e}`==`${n}`);if(Array.isArray(e))return Array.isArray(n)?(u.debug`arrays a: ${e} b: ${n}`,e.length!==n.length?!1:e.length===0?!0:e.every((r,i)=>l(r,n[i]))):(u.info`Is it intentional trying to compare an array a: ${e} to not array b: ${n}?`,!1);if(typeof e=="object"){if(typeof n!="object")return u.warn`b is not a primitive, not a Promise, not a function, not an array, not an object.
        What is b: ${n}?`,!1;u.debug`objects a: ${e} b: ${n}`;let r=Object.prototype.toString.call(e),i=Object.prototype.toString.call(n);if(R(e)||R(n))throw new TypeError(`At least one of a: ${e} and b: ${n} is an AsyncGenerator.
          We cannot handle comparing them in a sync function.
          Try equalAsync()`);if(g(e)||g(n))throw new TypeError(`At least one of a: ${e} and b: ${n} is an AsyncIterable.
      We cannot handle comparing them in a sync function.
      Try equalAsync()`);if(U(e))return U(n)?(u.debug`dates a: ${e} b: ${n}`,e.getTime()===n.getTime()):(u.info`Is it intentional trying to compare a Date a: ${e} to not a Date b: ${n}?`,!1);if(r==="[object Boolean]")return u.warn`The use of Boolean() the object wrapper is greatly discouraged. Found a: ${e}`,i!=="[object Boolean]"?(u.info`Is it intentional trying to compare a Boolean wrapped a: ${e} to not a Boolean wrapped b: ${n}?`,!1):(u.debug`Boolean wraps a: ${e} b: ${n}`,e.valueOf()===n.valueOf());if(B(e))return B(n)?(u.debug`Errors a: ${e} b: ${n}`,e.message!==n.message?!1:e.name!==n.name?(u.info`Is it intentional,
          giving two errors of different classes a: ${e.name} b: ${n.name}
          the same message: ${e.message}?`,!1):!!l(e?.cause,n?.cause)):(u.info`Is it intentional trying to compare a error a: ${e} to not error b: ${n}?`,!1);if(W(e))return W(n)?(u.info`comparing two Generators would only succeed
        if both of them never takes any parameters.`,l(c(e),c(n))):(u.info`Is it intentional trying to compare a Generator a: ${e} to not a Generator b: ${n}?`,!1);if(C(e))return C(n)?(u.debug`regexps a: ${e} b: ${n}`,`${e}`==`${n}`):(u.info`Is it intentional trying to compare a regex a: ${e} to not a regex b: ${n}?`,!1);if(S(e))return S(n)?(u.debug`maps a: ${e} b: ${n}`,e.size!==n.size?!1:e.size===0?!0:l(c(e),c(n))):(u.info`Is it intentional trying to compare a map a: ${e} to not a map b: ${n}?`,!1);if(j(e))return j(n)?(u.debug`sets a: ${e} b: ${n}`,e.size!==n.size?!1:e.size===0?!0:l(c(e),c(n))):(u.info`Is it intentional trying to compare a set a: ${e} to not a set b: ${n}?`,!1);if(O(e)||O(n))throw new TypeError("WeakMaps are not enumerable, therefore cannot be compared.");if(F(e)||F(n))throw new TypeError("WeakSets are not enumerable, therefore cannot be compared.");if(G(e))return u.info`Comparing two objects cannot rule out Proxy objects. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#constructor`,G(n)?(u.debug`Objects a: ${e} b: ${n}`,Object.keys(e).length!==Object.keys(n).length?!1:Object.keys(e).every(s=>l(e[s],n[s]))):(u.info`Is it intentional trying to compare an object Object a: ${e} to not an object Object b: ${n}?`,!1);throw new TypeError(`The comparison of object types ${r} and ${i} have not been implemented.`)}throw new TypeError(`at least one of a and b are not primitives, not Promises, not functions, not arrays, not objects.
  What are they?
  a: ${e}
  b: ${n}`)}t(l,"equal");async function J(e,n){if(N(e)||N(n)){u.debug`Promises a: ${e} b: ${n}`;let[r,i]=await Promise.allSettled([e,n]);return u.debug`settled a: ${r} b: ${i}`,l(r,i)}return R(e)&&R(n)?(u.info`Comparing two Generators or AsyncGenerators can only succeed
    if both of them never takes any parameters.`,l(await d(e),await d(n))):g(e)&&g(n)?l(await d(e),await d(n)):l(e,n)}t(J,"equalAsync");function z(e){return!e}t(z,"BooleanNot");function Gt(e){return function(n){return l(n,e)}}t(Gt,"equals");function Wt(e){return async function(n){return await J(n,e)}}t(Wt,"equalsAsync");function h(e){return function(n){if(l(n,e))return n;throw new Error(`input ${n} isn't equal to ${e}`)}}t(h,"equalsOrThrow");function Z(e){return async function(n){if(await J(n,e))return n;throw new Error(`input ${n} isn't equal to ${e}`)}}t(Z,"equalsAsyncOrThrow");function qt(e){return e.constructor.name==="AsyncFunction"}t(qt,"isAsyncFunction");function o(e){return e.constructor.name==="Function"}t(o,"isSyncFunction");function D(e){return t(function(r){return e(r)},"unaryfied")}t(D,"unary");function zt(e){return t(function(r,i){return e(r,i)},"binaryfied")}t(zt,"binary");function Dt(e){return t(function(r,i,s){return e(r,i,s)},"binaryfied")}t(Dt,"trinary");async function Ht(e,n,r,i,s,a,_,p,y,x){return n?r?i?s?a?_?p?y?x?await x(await y(await p(await _(await a(await s(await i(await r(await n(e))))))))):await y(await p(await _(await a(await s(await i(await r(await n(e)))))))):await p(await _(await a(await s(await i(await r(await n(e))))))):await _(await a(await s(await i(await r(await n(e)))))):await a(await s(await i(await r(await n(e))))):await s(await i(await r(await n(e)))):await i(await r(await n(e))):await r(await n(e)):await n(e):e}t(Ht,"pipedAsync");function ie(e,n,r,i,s,a,_,p,y,x){return n?r?i?s?a?_?p?y?x?o(e)&&o(n)&&o(r)&&o(i)&&o(s)&&o(a)&&o(_)&&o(p)&&o(y)&&o(x)?t(function(...T){return x(y(p(_(a(s(i(r(n(e(...T))))))))))},"fn0to9"):t(async function(...T){return await x(await y(await p(await _(await a(await s(await i(await r(await n(await e(...T))))))))))},"fn0to9"):o(e)&&o(n)&&o(r)&&o(i)&&o(s)&&o(a)&&o(_)&&o(p)&&o(y)?t(function(...T){return y(p(_(a(s(i(r(n(e(...T)))))))))},"fn0to8"):t(async function(...T){return await y(await p(await _(await a(await s(await i(await r(await n(await e(...T)))))))))},"fn0to8"):o(e)&&o(n)&&o(r)&&o(i)&&o(s)&&o(a)&&o(_)&&o(p)?t(function(...T){return p(_(a(s(i(r(n(e(...T))))))))},"fn0to7"):t(async function(...T){return await p(await _(await a(await s(await i(await r(await n(await e(...T))))))))},"fn0to7"):o(e)&&o(n)&&o(r)&&o(i)&&o(s)&&o(a)&&o(_)?t(function(...T){return _(a(s(i(r(n(e(...T)))))))},"fn0to6"):t(async function(...T){return await _(await a(await s(await i(await r(await n(await e(...T)))))))},"fn0to6"):o(e)&&o(n)&&o(r)&&o(i)&&o(s)&&o(a)?t(function(...T){return a(s(i(r(n(e(...T))))))},"fn0to5"):t(async function(...T){return await a(await s(await i(await r(await n(await e(...T))))))},"fn0to5"):o(e)&&o(n)&&o(r)&&o(i)&&o(s)?t(function(...T){return s(i(r(n(e(...T)))))},"fn0to4"):t(async function(...T){return await s(await i(await r(await n(await e(...T)))))},"fn0to4"):o(e)&&o(n)&&o(r)&&o(i)?t(function(...T){return i(r(n(e(...T))))},"fn0to3"):t(async function(...T){return await i(await r(await n(await e(...T))))},"fn0to3"):o(e)&&o(n)&&o(r)?t(function(...T){return r(n(e(...T)))},"fn0to2"):t(async function(...T){return await r(await n(await e(...T)))},"fn0to2"):o(e)&&o(n)?t(function(...T){return n(e(...T))},"fn0to1"):t(async function(...T){return await n(await e(...T))},"fn0to1"):e}t(ie,"pipeAsync");function Qt(e,n,r,i,s,a,_,p,y,x){return n?r?i?s?a?_?p?y?x?t(function(...T){return x(y(p(_(a(s(i(r(n(e(...T))))))))))},"fn0to9"):t(function(...T){return y(p(_(a(s(i(r(n(e(...T)))))))))},"fn0to8"):t(function(...T){return p(_(a(s(i(r(n(e(...T))))))))},"fn0to7"):t(function(...T){return _(a(s(i(r(n(e(...T)))))))},"fn0to6"):t(function(...T){return a(s(i(r(n(e(...T))))))},"fn0to5"):t(function(...T){return s(i(r(n(e(...T)))))},"fn0to4"):t(function(...T){return i(r(n(e(...T))))},"fn0to3"):t(function(...T){return r(n(e(...T)))},"fn0to2"):t(function(...T){return n(e(...T))},"fn0to1"):t(function(...T){return e(...T)},"fn0to0")}t(Qt,"pipe");async function rr(...e){return(await k(D(d),e)).flat()}t(rr,"concatArrayLikesAsync");function ir(...e){return $(D(c),e).flat()}t(ir,"concatArrayLikes");async function pr(e,n){return!await q(ie(e,z),n)}t(pr,"everyArrayLikeAsync");async function fr(e,n){return!await q(e,n)}t(fr,"everyFailArrayLikeAsync");async function yr(e,n){return!(await Promise.all(await k(e,n))).some(Boolean)}t(yr,"noneArrayLikeAsync");async function mr(e,n){return!(await Promise.all(await k(e,n))).some(z)}t(mr,"noneFailArrayLikeAsync");function dr(...e){return e}t(dr,"arrayOf");function*xr(...e){for(let n of e)yield n}t(xr,"genOf");async function wr(e,n){let r=[],i=[];for await(let s of n)await e(s)?r.push(s):i.push(s);return[r,i]}t(wr,"partitionArrAsync");async function Ar(e,n){let r=[],i=[];for await(let s of n)await e(s)?r.push(s):i.push(s);return[r,i]}t(Ar,"partitionArrayLikeAsync");function gr(e,n){let r=[],i=[];for(let s of n)e(s)?r.push(s):i.push(s);return[r,i]}t(gr,"partitionArrayLike");import{getConsoleSink as X,getFileSink as we,getLevelFilter as se,withFilter as ae}from"@logtape/logtape";function Lr(e="monochromatic"){return{sinks:{console:X(),consoleInfoPlus:ae(X(),se("info")),consoleWarnPlus:ae(X(),se("warning")),file:we(`${e}.log`,{formatter(n){return`${JSON.stringify(n,null,2)}
`}})},filters:{},loggers:[{category:["a"],level:"debug",sinks:["file","consoleInfoPlus"]},{category:["t"],level:"debug",sinks:["file","consoleInfoPlus"]},{category:["m"],level:"debug",sinks:["file","consoleWarnPlus"]},{category:["esbuild-plugin"],level:"debug",sinks:["file","consoleWarnPlus"]},{category:["logtape","meta"],level:"warning",sinks:["console"]}]}}t(Lr,"logtapeConfiguration");var Er=["a","index"];import{getLogger as Ae}from"@logtape/logtape";var Y=new URL(import.meta.url).pathname.split("/").at(-1),ge=Y.endsWith(".test.js")?Y.slice(0,-8):Y,m=Ae(["t",ge]);async function vr(e,n,r){m.debug`suite ${e} started: ${n.length} tests or suites`;let i=await Promise.allSettled(n);if(r){if(Object.hasOwn(r,"skip"))return{name:e,skip:r.skip};if(Object.hasOwn(r,"todo"))return m.info`suite ${e} finished: ${JSON.stringify(i)}`,{name:e,todo:r.todo,result:i}}let s=i.find(a=>a.status==="rejected");if(s)throw new Error(`suite ${e} errored with result: ${JSON.stringify(i)}`,{cause:s.reason});return m.debug`suite ${e} finished: ${JSON.stringify(i)}`,{name:e,result:i}}t(vr,"suite");async function Mr(e,n,r){let i=0,s=0;if(r){if(Object.hasOwn(r,"skip"))return m.warn`${e} skipped: ${r.skip}`,{name:e,skip:r.skip};if(Object.hasOwn(r,"timeLimit")&&(i=typeof r.timeLimit=="number"?r.timeLimit:await(async()=>{let a=performance.now();try{await r.timeLimit()}catch(p){m.info`timeLimit fn threw ${p}
            If this is intentional, you can ignore this log.
            The test will continue,
            the time it takes would be compared to the time timeLimit fn executed until it errored.`}return performance.now()-a})(),m.debug`${e} timeLimit: ${i}ms`),Object.hasOwn(r,"todo")){m.info`${e} started: ${n} with todo: ${r.todo}`;try{let a=performance.now(),_=await n();if(s=performance.now()-a,m.debug`${e} took: ${s}ms`,_!=null){if(s>i){let y=100*(s-i)/i;return m.error`${e} with todo: ${r.todo} took: ${s}ms, ${s-i}ms longer than timeLimit: ${i}ms, that's ${y}% too long. finished: ${_}`,{name:e,todo:r.todo,result:_,tooLongPercentage:y}}return m.warn`${e} with todo: ${r.todo} finished: ${_}`,{name:e,todo:r.todo,result:_}}if(s>i){let y=Math.round(100*(s-i)/i);return m.error`${e} with todo: ${r.todo} took: ${Math.round(s)}ms, ${Math.round(s-i)}ms longer than timeLimit: ${i}ms, that's ${y}% too long.`,{name:e,todo:r.todo,tooLongPercentage:y}}return m.warn`${e} with todo: ${r.todo} finished`,{name:e,todo:r.todo}}catch(a){return m.error`${e} with todo: ${r.todo} errored: ${a}`,{name:e,todo:r.todo,result:a}}}}m.debug`${e} started: ${String(n).slice(0,64)}`;try{let a=await n();if(s>i){let _=Math.round(100*(s-i)/i);throw new RangeError(`${e} took: ${Math.round(s)}ms, ${Math.round(s-i)}ms longer than timeLimit: ${i}ms, that's ${_}% too long. finished: ${a}`)}return a!=null?(m.info`${e} finished: ${a}`,{name:e,result:a}):(m.debug`${e} finished`,e)}catch(a){throw new Error(`${e}: ${String(n)} errored`,{cause:a})}}t(Mr,"test");export{z as BooleanNot,Qn as addBigints,Hn as addBigintsAsync,Vn as addNumbers,Yn as addNumbersAsync,Kn as addNumerics,Zn as addNumericsAsync,c as arrayFrom,d as arrayFromAsync,I as arrayIsEmpty,M as arrayIsNonEmpty,dr as arrayOf,P as assert,mn as assert0,rn as assert0Async,cn as assert1,sn as assert1Async,b as assertAsync,fn as assertEmptyArray,nn as assertEmptyArrayAsync,yn as assertEmptyObject,tn as assertEmptyObjectAsync,_n as assertFalse,Ze as assertFalseAsync,ln as assertNan,an as assertNanAsync,dn as assertNegative1,Tn as assertNegative1Async,pn as assertNull,en as assertNullAsync,E as assertThrow,L as assertThrowAsync,En as assertThrowError,gn as assertThrowErrorAsync,In as assertThrowRangeError,kn as assertThrowRangeErrorAsync,$n as assertThrowReferenceError,hn as assertThrowReferenceErrorAsync,Nn as assertThrowTypeError,Rn as assertThrowTypeErrorAsync,vn as assertThrowURIError,Ln as assertThrowURIErrorAsync,on as assertTrue,Qe as assertTrueAsync,un as assertUndefined,Ke as assertUndefinedAsync,Ne as atArrayLike,Ee as atArrayLikeAsync,Tt as awaits,zt as binary,Q as chunksArray,Oe as chunksArrayLike,je as chunksArrayLikeAsync,ir as concatArrayLikes,rr as concatArrayLikesAsync,xt as concatStrings,H as entriesArrayLike,V as entriesArrayLikeAsync,l as equal,J as equalAsync,Gt as equals,Wt as equalsAsync,Z as equalsAsyncOrThrow,h as equalsOrThrow,pr as everyArrayLikeAsync,fr as everyFailArrayLikeAsync,xr as genOf,w as isArray,qt as isAsyncFunction,R as isAsyncGenerator,g as isAsyncIterable,v as isEmptyArray,B as isError,de as isFinite,rt as isFloat,W as isGenerator,le as isInfinity,tt as isInteger,We as isIterable,S as isMap,Be as isMaybeAsyncIterable,ye as isNan,ce as isNegativeInfinity,Ue as isNonEmptyArray,me as isNonNanNumber,fe as isNumber,G as isObject,U as isObjectDate,ee as isPositiveInfinity,it as isPositiveNumber,re as isPrimitive,N as isPromise,C as isRegexp,xe as isSafeNumber,j as isSet,te as isString,o as isSyncFunction,O as isWeakMap,F as isWeakSet,Rt as joinStrings,gt as joinStringsAsync,Lr as logtapeConfiguration,Er as logtapeId,yr as noneArrayLikeAsync,mr as noneFailArrayLikeAsync,Un as notFalseOrThrow,Bn as notFalsyOrThrow,Wn as notNullOrThrow,Fn as notNullishOrThrow,Gn as notUndefinedOrThrow,wr as partitionArrAsync,gr as partitionArrayLike,Ar as partitionArrayLikeAsync,Qt as pipe,ie as pipeAsync,Ht as pipedAsync,q as somePromises,vr as suite,Mr as test,zn as throws,Dt as trinary,D as unary};
//# sourceMappingURL=index.js.map
